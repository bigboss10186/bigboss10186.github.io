---
layout:     post
title:      linux应用编程
subtitle:   linux API
date:       2019-04-20
author:     BY 孟超
header-img: img/H1eUzo_r2z.jpg
catalog: 	 true
tags:
    - linux API
---

主要就是学习Linux中的API。

# Linux中的应用编程

### 1、Linux中的文件IO

### 1、文件描述符：

(1)文件描述符其实实质是一个数字，这个数字在一个进程中表示一个特定的含义，当我们open打开一个文件时，操作系统在内存中构建了一些数据结构来表示这个动态文件，然后返回给应用程序一个数字作为文件描述符，这个数字就和我们内存中维护这个动态文件的这些数据结构挂钩绑定上了，以后我们应用程序如果要操作这一个动态文件，只需要用这个文件描述符进行区分。

(2)一句话讲清楚文件描述符：文件描述符就是用来区分一个程序打开的多个文件的。

(3)文件描述符的作用域就是当前进程，出了当前进程这个文件描述符就没有意义了

**在C语言中的文件指针中，其实文件指针是一个结构体，结构体里边就包含这个文件描述符**

一般用fd表示文件描述符



### 2、一些理解

我们的文件平时都在磁盘上，但是我们平时比如用word啊各种的编辑器，其实都是把文件从磁盘中读到内存中，然后编辑的是内存中的这一份。比如在用台式机写文档时，如果突然停电，文档就会丢失，就白写了。

在Linux中我们关于文件按IO的接口API函数有open、close、write、read、lseek这么几个函数。

在用这些函数的时候，经常要包含一些头文件，以及一些这些函数中的参数，我们其实很难记住的，我们就需要通过Linux中的man手册来查询。man 2 xxx就是查API的。



### 3、用各个API实例打开关闭和读写文件

**①打开文件**

API **open**函数

头文件包含：

```c
#include <sys/types.h>  
#include <sys/stat.h>
#include <fcntl.h>
```

函数原型：

`int open(const char *pathname, int flags);`

`int open(const char *pathname, int flags, mode_t mode);`

参数：

pathname：为文件的路径，可以带路径描述。

flags：文件打开方式。一会仔细写

mode：当flags满足一定条件就会使用mode位。

mode使用4个数字来指定权限的，其中后面三个很重要，对应我们要创建的这个文件的权限标志。譬如一般创建一个可读可写不可执行的文件就用0666

返回值：

返回值为文件描述符，如果失败则返回-1，（文件描述符不可能是负数）



**open函数flags详解**

O_RDONLY:以只读方式打开文件

O_WRONLY:以只写方式打开文件

O_RDWR:以读写方式打开文件

**以读写或者只写方式写文件时。是在文件的前面进行写操作，覆盖原有内容**

O_CREAT:如果该文件不存在，就创建一个新的文件，并用第三个参数为其设置权限

O_TRUNC:若文件已经存在，那么会删除文件中的全部原有数据，并且设置文件大小为0

O_APPEND:以添加方式打开文件，在打开文件的同时，文件指针指向文件的末尾，即将写入的数据添加到文件的末尾

O_CREAT:如果改文件不存在，就创建一个新的文件，并用第三个参数为其设置权限。如果文件按已经存在的话，则删除原来内容。

O_EXCL:如果使用O_CREAT时文件存在，则返回错误消息。这一参数可测试文件是否存在。此时open是原子操作，防止多个进程同时创建同一个文件

如果我CREAT要创建的是一个已经存在的名字的文件，则给我报错，不要去创建。这个效果就要靠O_EXCL标志和O_CREAT标志来结合使用。当这连个标志一起的时候，则没有文件时创建文件，有这个文件时会报错提醒我们。

O_NOCTTY:使用本参数时，若文件为终端，那么该终端不会成为调用open()的那个进程的控制终端

O_NONBLOCK: 如果pathname指的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选择项为此文件的本次打开操作和后续的I/O操作设置非阻塞方式。

O_SYNC:使每次write都等到物理I/O操作完成。

O_RSYNC:read 等待所有写入同一区域的写操作完成后再进行

在open()函数中，falgs参数可以通过“|”组合构成，但前3个标准常量（O_RDONLY，O_WRONLY，和O_RDWR）不能互相组合。

**O_NONBLOCK**
(1)阻塞与非阻塞。如果一个函数是阻塞式的，则我们调用这个函数时当前进程有可能被卡住（阻塞住，实质是这个函数内部要完成的事情条件不具备，当前没法做，要等待条件成熟），函数被阻塞住了就不能立刻返回；如果一个函数是非阻塞式的那么我们调用这个函数后一定会立即返回，但是函数有没有完成任务不一定。

(2)阻塞和非阻塞是两种不同的设计思路，并没有好坏。总的来说，阻塞式的结果有保障但是时间没保障；非阻塞式的时间有保障但是结果没保障。

(3)操作系统提供的API和由API封装而成的库函数，有很多本身就是被设计为阻塞式或者非阻塞式的，所以我们应用程度调用这些函数的时候心里得非常清楚。

(4)我们打开一个文件默认就是阻塞式的，如果你希望以非阻塞的方式打开文件，则flag中要加O_NONBLOCK标志。

(2)只用于设备文件，而不用于普通文件。



**O_SYNC**
(1)write阻塞等待底层完成写入才返回到应用层。

(2)无O_SYNC时write只是将内容写入底层缓冲区即可返回，然后底层（操作系统中负责实现open、write这些操作的那些代码，也包含OS中读写硬盘等底层硬件的代码）在合适的时候会将buf中的内容一次性的同步到硬盘中。这种设计是为了提升硬件操作的性能和销量，提升硬件寿命；但是有时候我们希望硬件不好等待，直接将我们的内容写入硬盘中，这时候就可以用O_SYNC标志。



**②关闭文件**

API**close**函数

头文件包含：

`#include <unistd.h>`

函数原型：

int close(int fd)

参数：

fd文件描述符

返回值：

0成功，-1出错



**③读文件**

APIread函数

头文件：

 `#include <unistd.h>`



函数原型：

ssize_t read(int fd, void *buf, size_t count);



参数： 

fd： 将要读取数据的文件描述词。 

buf：指缓冲区，即读取的数据会被放到这个缓冲区中去。 

count： 表示调用一次read操作，应该读多少数量的字符。



返回值：

ssize_t其实就是Linux中typedef之后的int而已

返回所读取的字节数；0（读到EOF）；-1（出错）。



以下几种情况会导致读取到的字节数小于 count ：

A. 读取普通文件时，读到文件末尾还不够 count 字节。例如：如果文件只有 30 字节，而我们想读取 100 字节，那么实际读到的只有 30 字节，read 函数返回 30 。此时再使用 read 函数作用于这个文件会导致 read 返回 0 。 

B. 从终端设备（terminal device）读取时，一般情况下每次只能读取一行。 

C. 从网络读取时，网络缓存可能导致读取的字节数小于 count字节。 

D. 读取 pipe 或者 FIFO 时，pipe 或 FIFO 里的字节数可能小于 count 。 

E. 从面向记录（record-oriented）的设备读取时，某些面向记录的设备（如磁带）每次最多只能返回一个记录。 

F. 在读取了部分数据时被信号中断。 读操作始于 cfo 。在成功返回之前，cfo 增加，增量为实际读取到的字节数。







**④写文件**

write（）函数

所需头文件：

` #include <unistd.h>`



函数原型：

ssize_t write(int fd, const void *buf, size_t count);

返回值：

写入文件的字节数（成功）；-1（出错）



参数：

fd：文件描述符

buf：缓冲区

count：一次写的字符数









**终止一个进程用exit函数，而return只能在main函数中推出**

包含头文件

**实例测试**

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[])
{
	int fd = -1;		// fd 就是file descriptor，文件描述符
    
	char buf[100] = {0};
	char writebuf[20] = "l love linux";
	int ret = -1;
	
	// 第一步：打开文件
	fd = open("a.txt", O_RDWR);
	if (-1 == fd)		// 有时候也写成： (fd < 0)
	{
		printf("文件打开错误\n");
        exit(-1);
	}
	else
	{
		printf("文件打开成功，fd = %d.\n", fd);
	}
	
	// 第二步：读写文件
	// 写文件
	ret = write(fd, writebuf, strlen(writebuf));
	if (ret < 0)
	{
		printf("write失败.\n");
	}
	else
	{
		printf("write成功，写入了%d个字符\n", ret);
	}
/*	
	// 读文件
	ret = read(fd, buf, 5);
	if (ret < 0)
	{
		printf("read失败\n");
	}
	else
	{
		printf("实际读取了%d字节.\n", ret);
		printf("文件内容是：[%s].\n", buf);
	}
*/	
	// 第三步：关闭文件
	close(fd);
	
	return 0;
}

```

**文件读写的一些细节**

**errno和perror**

(1)errno就是error number，意思就是错误号码。linux系统中对各种常见错误做了个编号，当函数执行错误时，函数会返回一个特定的errno编号来告诉我们这个函数到底哪里错了。

(2)errno是由OS来维护的一个全局变量，任何OS内部函数都可以通过设置errno来告诉上层调用者究竟刚才发生了一个什么错误。

(3)errno本身实质是一个int类型的数字，每个数字编号对应一种错误。当我们只看errno时只能得到一个错误编号数字（譬如-37），不适应于人看。

(4)linux系统提供了一个函数perror（意思print error），perror函数内部会读取errno并且将这个不好认的数字直接给转成对应的错误信息字符串，然后print打印出来。

**read和write的count**

(1)count和返回值的关系。count参数表示我们想要写或者读的字节数，返回值表示实际完成的要写或者读的字节数。实现的有可能等于想要读写的，也有可能小于（说明没完成任务）

(2)count再和阻塞非阻塞结合起来，就会更加复杂。如果一个函数是阻塞式的，则我们要读取30个，结果暂时只有20个时就会被阻塞住，等待剩余的10个可以读。

(3)有时候我们写正式程序时，我们要读取或者写入的是一个很庞大的文件（譬如文件有2MB），我们不可能把count设置为2*1024*1024，而应该去把count设置为一个合适的数字（譬如2048、4096），然后通过多次读取来实现全部读完。



**⑤lseek函数**

功能描述： 用于在指定的文件描述符中将将文件指针定位到相应位置。

头文件：

` #include <unistd.h>，#include <sys/types.h>`



函数原型：

off_t lseek(int fd, off_t offset,int whence);



参数：

fd;文件描述符

offset:偏移量，每一个读写操作所需要移动的距离，单位是字节，可正可负（向前移，向后移）

whence:就是参照物

SEEK_SET:当前位置为文件的开头，新位置为偏移量的大小

SEEK_CUR:当前位置为指针的位置，新位置为当前位置加上偏移量

SEEK_END:当前位置为文件的结尾，新位置为文件大小加上偏移量的大小



返回值：

成功：返回当前位移

失败：返回-1



**用lseek计算文件长度**

(1)linux中并没有一个函数可以直接返回一个文件的长度。但是我们做项目时经常会需要知道一个文件的长度，怎么办？自己利用lseek来写一个函数得到文件长度即可。

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>



int cal_len(const char *pathname)
{
	int fd = -1;		// fd 就是file descriptor，文件描述符
	int ret = -1;
	
	// 第一步：打开文件
    
	fd = open(pathname, O_RDONLY);
	if (-1 == fd)		// 有时候也写成： (fd < 0)
        
	{
		//printf("\n");
        
		perror("文件打开错误");
		// return -1;
        
		return -1;
	}
	
	// 此时文件指针指向文件开头
    
	// 我们用lseek将文件指针移动到末尾，然后返回值就是文件指针距离文件开头的偏移量，也就是文件的长度了
    
	ret = lseek(fd, 0, SEEK_END);
	
	return ret;
}



int main(int argc, char *argv[])
{
	int fd = -1;		// fd 就是file descriptor，文件描述符
    
	int ret = -1;
	
	if (argc != 2)
	{
		printf("usage: %s filename\n", argv[0]);
		_exit(-1);
	}
	

	printf("文件长度是：%d字节\n", cal_len(argv[1]));
	
	
	
	
	return 0;
}
```



**用lseek构建空洞文件**

(1)空洞文件就是这个文件中有一段是空的。

(2)普通文件中间是不能有空的，因为我们write时文件指针是依次从前到后去移动的，不可能绕过前面直接到后面。

(3)我们打开一个文件后，用lseek往后跳过一段，再write写入一段，就会构成一个空洞文件。

(4)空洞文件方法对多线程共同操作文件是及其有用的。有时候我们创建一个很大的文件，如果从头开始依次构建时间很长。

有一种思路就是将文件分为多段，然后多线程来操作每个线程负责其中一段的写入。









**多次打开同一文件与O_APPEND**

重复打开同一文件读取

(1)一个进程中两次打开同一个文件，然后分别读取，看结果会怎么样

(2)结果无非2种情况：一种是fd1和fd2分别读，第二种是接续读。经过实验验证，证明了结果是fd1和fd2分别读。

(3)分别读说明：我们使用open两次打开同一个文件时，fd1和fd2所对应的文件指针是不同的2个独立的指针。文件指针是包含在动态文件的文件管理表中的，所以可以看出linux系统的进程中不同fd对应的是不同的独立的文件管理表。

重复打开同一文件写入

(1)一个进程中2个打开同一个文件，得到fd1和fd2.然后看是分别写还是接续写？

(2)正常情况下我们有时候需要分别写，有时候又需要接续写，所以这两种本身是没有好坏之分的。关键看用户需求

(3)默认情况下应该是：分别写（实验验证过的）

加O_APPEND解决覆盖问题

有时候我们希望接续写而不是分别写？办法就是在open时加O_APPEND标志即可



### 4、复制文件描述符dup和dup2函数

![E9kBNQ.md.png](https://s2.ax1x.com/2019/04/19/E9kBNQ.md.png)



头文件：

`#include <unistd.h>`

函数原型：

`int dup(int oldfd);`

`int dup2(int oldfd, int newfd);`

当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。 

　　dup2和dup的区别就是可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭。如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。 



### 5、fcntl函数

### fcntl系统调用

功能描述：根据文件描述词来操作文件的特性。

函数原型：

```
`int` `fcntl(``int` `fd, ``int` `cmd); ``int` `fcntl(``int` `fd, ``int` `cmd, ``long` `arg); ``int` `fcntl(``int` `fd, ``int` `cmd, ``struct` `flock *lock); `
```

参数：

第一个参数是fd表示要操作哪个文件，

第二个参数是cmd表示要进行哪个命令操作。

变参是用来传递参数的，要配合cmd来使用。

有以下操作命令可供使用

**一、F_DUPFD：复制文件描述词。**

**二、FD_CLOEXEC ：设置close-on-exec标志。**

如果FD_CLOEXEC位是0，执行execve的过程中，文件保持打开。反之则关闭。 

**三、F_GETFD：读取文件描述词标志。** 

**四、F_SETFD：设置文件描述词标志。** 

**五、F_GETFL：读取文件状态标志。** 

**六、F_SETFL：设置文件状态标志。**

其中O_RDONLY， O_WRONLY， O_RDWR， O_CREAT，  O_EXCL， O_NOCTTY 和 O_TRUNC不受影响，能更改的标志有 O_APPEND，O_ASYNC， O_DIRECT， O_NOATIME 和 O_NONBLOCK。 

**七、F_GETLK, F_SETLK 和 F_SETLKW ：获取，释放或测试记录锁，使用到的参数是以下结构体指针：**

- F_SETLK：在指定的字节范围获取锁（F_RDLCK, F_WRLCK）或释放锁（F_UNLCK）。如果和另一个进程的锁操作发生冲突，返回 -1并将errno设置为EACCES或EAGAIN。          
- F_SETLKW：行为如同F_SETLK，除了不能获取锁时会睡眠等待外。如果在等待的过程中接收到信号，会即时返回并将errno置为EINTR。 
- F_GETLK：获取文件锁信息。 
- F_UNLCK：释放文件锁。

为了设置读锁，文件必须以读的方式打开。为了设置写锁，文件必须以写的方式打开。为了设置读写锁，文件必须以读写的方式打开。 

**八、信号管理** 

F_GETOWN, F_SETOWN, F_GETSIG 和 F_SETSIG 被用于IO可获取的信号。 

- F_GETOWN：获取当前在文件描述词 fd上接收到SIGIO 或 SIGURG事件信号的进程或进程组标识 。 
- F_SETOWN：设置将要在文件描述词fd上接收SIGIO 或 SIGURG事件信号的进程或进程组标识 。 
- F_GETSIG：获取标识输入输出可进行的信号。 
- F_SETSIG：设置标识输入输出可进行的信号。 

使用以上命令，大部分时间程式无须使用select()或poll()即可实现完整的异步I/O。 

**九、租约（ Leases）** 

1、F_SETLEASE 和 F_GETLEASE 被用于当前进程在文件上的租约。文件租约提供当一个进程试图打开或折断文件内容时，拥有文件租约的进程将会被通告的机制。 

2、F_SETLEASE：根据以下符号值设置或删除文件租约 

- F_RDLCK设置读租约，当文件由另一个进程以写的方式打开或折断内容时，拥有租约的当前进程会被通告。 
- F_WRLCK设置写租约，当文件由另一个进程以读或以写的方式打开或折断内容时，拥有租约的当前进程会被通告。 
- F_UNLCK删除文件租约。

3、F_GETLEASE：获取租约类型。 

**十、文件或目录改动通告** 

（linux 2.4以上）当fd索引的目录或目录中所包含的某一文件发生变化时，将会向进程发出通告。arg参数指定的通告事件有以下，两个或多个值能通过或运算组合。 

- DN_ACCESS 文件被访问 (read, pread, readv) 
- DN_MODIFY 文件被修改(write, pwrite,writev, truncate, ftruncate) 
- DN_CREATE 文件被建立(open, creat, mknod, mkdir, link, symlink, rename) 
- DN_DELETE 文件被删除(unlink, rmdir) 
- DN_RENAME 文件被重命名(rename) 
- DN_ATTRIB 文件属性被改动(chown, chmod, utime[s]) 

返回说明：   

成功执行时，对于不同的操作，有不同的返回值 

- F_DUPFD：新文件描述词 
- F_GETFD：标志值 
- F_GETFL：标志值 
- F_GETOWN：文件描述词属主 
- F_GETSIG：读写变得可行时将要发送的通告信号，或0对于传统的SIGIO行为 

对于其他命令返回0。 

失败返回-1，errno被设为以下的某个值   

- EACCES/EAGAIN: 操作不被允许，尚未可行 
- EBADF: 文件描述词无效 
- EDEADLK: 探测到可能会发生死锁 
- EFAULT: 锁操作发生在可访问的地å址空间外 
- EINTR: 操作被信号中断 
- EINVAL： 参数无效 
- EMFILE: 进程已超出文件的最大可使用范围 
- ENOLCK: 锁已被用尽 
- EPERM:权能不允许 

### 4、linux 中 stat 函数的用途和使用方法

**stat 函数讲解**

头文件: 

   #include <sys/stat.h>

   \#include <unistd.h>

定义函数:    

int stat ( const char *file_name , struct stat *buf );

```c
struct stat {
    dev_t         st_dev;       //文件的设备编号
    ino_t         st_ino;       //节点
    mode_t        st_mode;      //文件的类型和存取的权限
    nlink_t       st_nlink;     //连到该文件的硬连接数目，刚建立的文件值为1
    uid_t         st_uid;       //用户ID
    gid_t         st_gid;       //组ID
    dev_t         st_rdev;      //(设备类型)若此文件为设备文件，则为其设备编号
    off_t         st_size;      //文件字节数(文件大小)
    unsigned long st_blksize;   //块大小(文件系统的I/O 缓冲区大小)
    unsigned long st_blocks;    //块数
    time_t        st_atime;     //最后一次访问时间
    time_t        st_mtime;     //最后一次修改时间
    time_t        st_ctime;     //最后一次改变时间(指属性)
};
```



先前所描述的st_mode 则定义了下列数种情况：

```c
    S_IFMT   0170000    文件类型的位掩码
    S_IFSOCK 0140000    scoket
    S_IFLNK 0120000     符号连接
    S_IFREG 0100000     一般文件
    S_IFBLK 0060000     区块装置
    S_IFDIR 0040000     目录
    S_IFCHR 0020000     字符装置
    S_IFIFO 0010000     先进先出

    S_ISUID 04000     文件的(set user-id on execution)位
    S_ISGID 02000     文件的(set group-id on execution)位
    S_ISVTX 01000     文件的sticky位

    S_IRUSR(S_IREAD) 00400     文件所有者具可读取权限
    S_IWUSR(S_IWRITE)00200     文件所有者具可写入权限
    S_IXUSR(S_IEXEC) 00100     文件所有者具可执行权限

    S_IRGRP 00040             用户组具可读取权限
    S_IWGRP 00020             用户组具可写入权限
    S_IXGRP 00010             用户组具可执行权限

    S_IROTH 00004             其他用户具可读取权限
    S_IWOTH 00002             其他用户具可写入权限
    S_IXOTH 00001             其他用户具可执行权限
```

上述的文件类型在POSIX中定义了检查这些类型的宏定义：   

```c
    S_ISLNK (st_mode)    判断是否为符号连接
    S_ISREG (st_mode)    是否为一般文件
    S_ISDIR (st_mode)    是否为目录
    S_ISCHR (st_mode)    是否为字符装置文件
    S_ISBLK (s3e)        是否为先进先出
    S_ISSOCK (st_mode)   是否为socket
```



函数说明: 

   通过文件名filename获取文件信息，并保存在buf所指的结构体stat中



返回值:   

   执行成功则返回0，失败返回-1，错误代码存于errno



**fstat函数**

```c
int fstat(int fd, struct stat *buf);
```

传参是文件描述符



**lstat函数**

```c
int lstat(const char *restrict pathname, struct stat *restrict buf);
```

lstat函数和stat和fstat的区别是lstat是直接查看链接文件的属性。而stat和fstat是看的连接文件指向的文件的属性





**access函数检查权限设置**

(1)文本权限管控其实蛮复杂，一般很难很容易的确定对一个文件是否具有某种权限。设计优秀的软件应该是：在操作某个文件之前先判断当前是否有权限做这个操作，如果有再做如果没有则提供错误信息给用户。

(2)access函数可以测试得到当前执行程序的那个用户在当前那个环境下对目标文件是否具有某种操作权限。

**chmod/fchmod与权限修改**

(1)chmod是一个linux命令，用来修改文件的各种权限属性。chmod命令只有root用户才有权利去执行修改。

(2)chmod命令其实内部是用linux的一个叫chmod的API实现的。

**chown/fchown/lchown与属主修改**

(1)linux中有个chown命令来修改文件属主

(2)chown命令是用chown API实现的

**umask与文件权限掩码**

(1)文件掩码是linux系统中维护的一个全局设置，umask的作用是用来设定我们系统中新创建的文件的默认权限的。

(2)umask命令就是用umask API实现的





**opendir - open a directory**

头文件：

`#include <sys/types.h> `

`#include <dirent.h>`

函数原型：

`DIR *opendir(const char *name);`

描述：

opendir函数打开一个与给定的目录名name相对应的目录流，并返回一个指向该目录流的指针。打开后，该目录流指向了目录中的第一个目录项。

返回值：

opendir函数，打开成功，返回指向目录流的指针；打开失败，则返回NULL，并设置相应的错误代码errno。

**readdir - read a directory**

头文件：
`#include <sys/types.h>`

`#include <dirent.h>`

函数原型：

`struct dirent *readdir(DIR *dir);`

描述：

readdir函数返回一个指向dirent结构体的指针，该结构体代表了由dir指向的目录流中的下一个目录项；如果读到end-of-file或者出现了错误，那么返回NULL。

在Linux系统中，dirent结构体定义如下：

```c
    struct dirent { 
             ino_t          d_ino;       /* inode number */ 
             off_t          d_off;       /* offset to the next dirent */ 
             unsigned short d_reclen;    /* length of this record */ 
             unsigned char  d_type;      /* type of file */ 
             char           d_name[256]; /* filename */ 
         };
```



readdir函数返回的值会被后续调用的（针对同一目录流的）readdir函数返回值所覆盖。

返回值：

readdir函数，成功时返回一个指向dirent结构体的指针；失败时或读到end-of-file时，返回NULL，并且设置相应的错误代码errno。

**closedir - close a directory**



头文件：

`#include <sys/types.h>`

`#include <dirent.h>`

函数原型：

`int closedir(DIR *dir);`

描述：

closedir函数关闭与指针dir相联系的目录流。关闭后，目录流描述符dir不再可用。

返回值：

closedir函数，成功时返回0；失败是返回-1，并设置相应的错误代码errno。



