---
layout:     post
title:      从刷机开始学ARM
subtitle:   arm
date:       2019-04-08
author:     BY 孟超
header-img: img/r1zx86E3z.jpg
catalog: 	 true
tags:
    - arm
---

# 1、ARM刷机

刷机有很多种方法，这里介绍一种最简单的方法，就是fastboot刷机。

以后要是不小心把开发板刷成砖头了，可以用dnw的方式双击，这种方法可以解决一切问题。



我用的是九鼎的s5pv210的开发板。以下都是用这个开发板讲解的。

**安装USB转串口线的驱动**

我们在刷机的时候需要看输出的信息，需要用串口进行打印输出信息。我们现在的电脑都很少有用哪种DB9接口了，都是USB接口，所以我们需要安装USB转串口驱动。

使用secureCRT进行观看打印的信息，也可以使用MobaXterm进行查看，前一个需要破解，后面的有个人免费的绿色版。

在我那个开发板中串口只能使用**串口2**（uboot中就是这么设置的），因为是使用这个串口进行信息输出。

**破坏iNand中的bootloader以从SD2启动**

在进入linux系统之后的命令行中写下这两句即可破坏

​	busybox dd if=/dev/zero of=/dev/block/mmcblk0 bs=512 seek=1 count=1 conv=sync

​	sync

破坏板载iNand的bootloader后，不插外部SD卡，启动时串口得到：SD checksum Error



**制作启动SD卡（其实就是烧录uboot到SD卡中）**

有2种烧写方法：一种是在windows中用刷卡工具去制作启动SD卡；另一种是在linux中用dd命令。

制作完SD后将SD卡插入开发板SD2通道（注意不是SD3），然后开机就可以进入uboot界面了。在uboot开机自动启动倒数3秒之内迅速按下电脑回车键，打断自动启动。（否则会自动启动iNand中的android）。



**fastboot介绍**

fastboot是uboot中用来快速下载镜像的一个命令，fastboot同时还是一个windows上的软件。
fastboot下载时要注意1：fastboot是使用USB线进行数据传输的，所以fastboot执行之前要先连接开发板和主机之间的usb线。
fastboot下载时要注意2：需要安装驱动。



**fastboot驱动**

fastboot需要安装驱动，对应的安装上即可。



**fastboot常用命令**

fastboot devices		       命令用来查看当前连接的设备。（我们开发板看到的是：SMDKC110-01）
fastboot flash xxx		    命令用来烧录的
fastboot reboot			命令用来重启系统





**使用fastboot烧录android4.0.4镜像**



先在uboot的界面输入fastboot，然后就可以了，可以设置uboot的参数

uboot的参数设置：set bootcmd 'movi read kernel 30008000; bootm 30008000'（默认就是这个，不用设置也行）



在cmd下使用以下三个命令来完成烧录
fastboot flash bootloader android4.0/uboot.bin		烧uboot
fastboot flash kernel android4.0/zImage-android		烧linux kernel
fastboot flash system android4.0/x210.img			烧android rom



后面的对应的文件夹。

刷机完成。



# 2、dnw工具的使用及下载程序

**dnw工具的介绍**

dnw是一个软件，是三星公司编写的，这个软件的功能是通过USB线连接开发板和电脑主机，然后从主机下载文件镜像到开发板中去烧录系统。

​	dnw软件使用注意1：dnw是需要装usb驱动的，驱动在“X210光盘资料\A盘\tools\USB驱动”目录中

​	dnw软件使用注意2：dnw使用时通过usb线下载，所以一定要插USB线。

​	dnw软件使用注意3：dnw下载时需要设置dnw下载内存地址。在dnw软件的菜单“Configuration”中设置Download Address为0xd0020010，确认即可。

**dnw驱动安装**

​	X210开发板使用了软开关，但是我们这里还没到操作系统没去处理开关，所以在整个裸机实验中必须手工按下POWER键才能保持开机，只要手一抬起来就关机了····

​	dnw驱动装好的标志是：开发板开机从usb启动后，设备管理器中显示已经安装的设备，并且关键是dnw工具中USB:OK

**裸机程序下载地址设置**

​	从usb启动做裸机实验时，因为不需要16字节的校验头，所以直接下载到0xd0020010

**usb启动裸机实验总结**

​	usb启动方式主要是用来调试程序的，其实分析S5PV210即可知道，我们这里是把裸机程序当作BL1来使用了。

扩充知识：Windows X64版本驱动安装非常麻烦，因为微软启用了USB设备驱动签名政策。我们可以去除签名。

可以在使用的时候，进入设置中的更新和安全中的恢复，重新启动电脑，进行设置。



# 3、SD卡下载程序

从SD启动时会先从iNand（SD0）启动执行，当iNand启动做校验和时失败才会转为启动SD2。而我们做裸机实验时是通过SD2来提供裸机程序镜像的，因此需要先破坏内部iNand的uboot才可以强迫开发板从SD2启动去执行我们的裸机程序。



**linux下用dd命令下载SD卡程序**

后面会讲，后面再到这里讲。后面会把这句话删除。



# 4、安装交叉编译工具链

**交叉编译工具链的选择**

​	我们选择交叉编译工具链的原则：和我们所使用的目标平台（给哪款SoC编程）尽量去匹配。譬如我们开发S5PV210的程序就是用arm-2009q3这个版本，因为三星官方在开发S5pv210时就使用这个版本的交叉编译工具链，这样可以最大限度的避免稀奇古怪的问题出现。

**交叉编译工具链的安装**

​	步骤1：打开虚拟机，在/usr/local/下创建/usr/local/arm文件夹

​	步骤2：先将安装包从Windows中弄到linux中去。可以用共享文件夹，也可以用Samba，也可以cuteftp。

​	步骤3：解压。tar -jxvf arm-2009q3.tar.bz2

到此相当于程序已经安装完毕，真正的应用程序安装在/usr/local/arm/arm-2009q3/bin目录下

我们装软一般都在/usr目录下。我们安装arm-linux-gcc，就在/usr/local/底下创建一个arm文件夹，然后装到里面。



到真正的应用程序的安装目录下（也就是/usr/local/arm/arm-2009q3/bin），去执行arm-linux-gcc -v

执行方法是：./arm-none-linux-gnueabi-gcc -v

​	执行后可以得到一长串输出，其中有“gcc version 4.4.1 ”字样，即表示安装成功。



**将工具链导出到环境变量**

export PATH=/usr/local/arm/arm-2009q3/bin:$PATH

​	在一个终端中执行以上命令后，该终端中就可以直接使用arm-linux-gcc了，但是只要关掉这个终端再另外打开一个立马就不行了。

​	原因是我们本次终端中执行时的操作只是针对本终端，以后再打开的终端并未被执行过这个命令所以没导出。

​	解决方案是在~/.bashrc中，添加export PATH=/usr/local/arm/arm-2009q3/bin:$PATH 即可。注意：我们导出这个环境变量是在当前用户，如果你登录时在其他用户下是没用的。



**为工具链创建arm-linux-xxx符号链接**

​	ln arm-none-linux-gnueabi-addr2line -s arm-linux-addr2line

其他的照样进行符号链接即可。可以用shell脚本来完成这个工作，比较方便一些，不过要在linux中写shell脚本文件，不然的话，会有那个换行符号的差异问题，可能不会成功。



# 5、mkv210_image.c的作用

为BL1添加校验头

​	我们编译链接时只得到了led.bin，这个210.bin的得到和交叉编译工具链是完全无关的。由led.bin得到210.bin的过程是三星的S5PV210所特有的，因此需要我们自己去完成，为此我们写了mkv210_image.c来完成。



# 6、汇编点亮LED

在学习的过程中我们的第一个实验总是点亮LED，因为这个很简单，并且还能够了解一下整体情况。就像我们学任何一门编程语言都是打印helloworld一样，下面就来实现汇编。

在这里还不能使用C语言，因为并没有初始化栈，所以C语言不可以使用。

**①首先查询原理图**

查阅原理图，发现开发板上一共有5颗LED。其中一颗D26的接法是：正极接5V，负极接地。因此这颗LED只要上电就会常亮。因此我们分析这颗LED是电源指示灯。

​	剩下4颗LED的接法是：正极接3.3V，负极接了SoC上的一个引脚（GPIO），具体详细接法是：

​	D22：GPJ0_3

​	D23：GPJ0_4

​	D24：GPJ0_5

​	D25：PWMTOUT1(GPD0_1)	

**点亮及熄灭LED（GPIO）**

因为正极已经定了（3.3V），而负极接在了SoC的引脚上，可以通过SoC中编程来控制负极的电压值，因此我们可以通过程序控制负极输出低电平（0V），这样在正负极上就有了压差，LED即可点亮。

**②查阅数据手册可知，GPJ0相关的寄存器有以下：**
GPJ0CON, （GPJ0 control）GPJ0控制寄存器，用来配置各引脚的工作模式	

GPJ0DAT, （GPJ0 data）当引脚配置为input/output模式时，寄存器的相应位和引脚的电平高低相对应。

GPJ0PUD, （pull up down）控制引脚内部弱上拉、下拉

GPJ0DRV, （driver）配置GPIO引脚的驱动能力

GPJ0CONPDN，（记得是低功耗模式下的控制寄存器）

GPJ0PUDPDN  （记得是低功耗模式下的上下拉寄存器）

注：在驱动LED点亮时，应该将GPIO配置为output模式。

实际上真正操控LED的硬件，主要的有：GPJ0CON, GPJ0DAT 这么2个。



**③写汇编点亮LED**



```汇编
_start:

	// 第一步：把0x11111111写入0xE0200240(GPJ0CON)位置
	
	ldr r0, =0x11111111			// 从后面的=可以看出用的是ldr伪指令，因为需要编译器来判断这个数
	
	ldr r1, =0xE0200240			// 是合法立即数还是非法立即数。一般写代码都用ldr伪指令
	
	str r0, [r1]				// 寄存器间接寻址。功能是把r0中的数写入到r1中的数为地址的内存中去
	

	// 第二步：把0x0写入0xE0200244(GPJ0DAT)位置
	
	ldr r0, =0x0
	
	ldr r1, =0xE0200244
	
	str r0, [r1]				// 把0写入到GPJ0DAT寄存器中，引脚即输出低电平，LED点亮
	

flag:							// 这两行写了一个死循环。因为裸机程序是直接在CPU上运行的，CPU会

	b flag						// 逐行运行裸机程序直到CPU断电关机。如果我们的程序所有的代码都
	
								// 执行完了CPU就会跑飞（跑飞以后是未定义的，所以千万不能让CPU
								
								// 跑飞），不让CPU跑飞的办法就是在我们整个程序执行完后添加死循环

```



# 7、汇编写启动代码之关看门狗、初始化栈、开关icache



```

#define WTCON		0xE2700000			//查阅数据手册可以找到这个寄存器

#define SVC_STACK	0xd0037d80			//这个栈的位置，在IROM application中有说明，见那个图

.global _start					// 把_start链接属性改为外部，这样其他文件就可以看见_start了

_start:

	// 第1步：关看门狗（向WTCON的bit5写入0即可）
	
	ldr r0, =WTCON
	
	ldr r1, =0x0
	
	str r1, [r0]
	
	// 第2步：设置SVC栈
	
	ldr sp, =SVC_STACK
	
	// 第3步：开/关icache
	
	mrc p15,0,r0,c1,c0,0;			// 读出cp15的c1到r0中
	
	//bic r0, r0, #(1<<12)			// bit12 置0  关icache
	
	orr r0, r0, #(1<<12)			// bit12 置1  开icache
	
	mcr p15,0,r0,c1,c0,0;
	

	// 从这里之后就可以开始调用C程序了
	
	bl led_blink					// led_blink是C语言实现的一个函数
	
// 汇编最后的这个死循环不能丢
	b .
	

```



初始化栈之后可以使用C语言了，C语言访问寄存器和内存的方法是这样的

**使用C语言来访问寄存器的语法**
	寄存器的地址类似于内存地址（IO与内存统一编址的），所以这里的问题是用C语言读写寄存器，就是用C语言来读写内存地址。用C语言来访问内存，就要用到指针

​	unsigned int *p = (unsigned int *)0x0xE0200240;
​	*p = 0x11111111;


上面这两句其实可以简化为1句：*((unsigned int *)0x0xE0200240) = 0x11111111;



**神奇的volatile**

​	volatile的作用是让程序在编译时，编译器不对程序做优化。优化有时候是ok的，但是有时候是自作聪明会造成程序不对。如果你的一个变量是易变的，不希望编译器帮我们做优化，就在这个变量定义时加volatile。

​	加不加有没有差别，取决于编译器。如果编译器做了优化则有差异；如果编译器本身没做优化，那就没有差别。
​	在我们这里（编译器是arm-2009q3），实际测试加不加效果是一样的。



# 8、重定位与链接脚本

位置无关编码(PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。

位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。

链接地址：链接时指定的地址（指定方式为：Makefile中用-Ttext，或者链接脚本）

运行地址：程序实际运行时地址（指定方式：由实际运行时被加载到内存的哪个位置说了算）

**回头看一下s5pv210的启动方式，就会明白为什么需要重定位了**



链接地址是由程序员在编译链接的过程中，通过Makefile中-Ttext xxx或者在链接脚本中指定的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。

举例：1、linux中的应用程序。gcc hello.c -o hello，这时使用默认的链接地址就是0x0，所以应用程序都是链接在0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享4G的虚拟地址空间。所以应用程序都可以链接到0地址，因为每个进程都是从0地址开始的。（编译时可以不给定链接地址而都使用0）

​	  2、210中的裸机程序。运行地址由我们下载时确定，下载时下载到0xd0020010，所以就从这里开始运行。（这个下载地址也不是我们随意定的，是iROM中的BL0加载BL1时事先指定好的地址，这是由CPU的设计决定的）。所以理论上我们编译链接时应该将地址指定到0xd0020010，但是实际上我们在之前裸机程序中都是使用位置无关码PIC，所以链接地址可以是0。



**程序段的概念：代码段、数据段、bss段（ZI段）、自定义段**

C语言中我有说过，可以在那里看，这里不再重复

**链接脚本概念**

链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理.o文件中那些段，将其链接成一个可执行程序。

​	链接脚本的关键内容有2部分：段名 + 地址（作为链接地址的内存地址）

​	链接脚本的理解：

​	SECTIONS {}	这个是整个链接脚本

​	. 点号在链接脚本中代表当前位置。

​	= 等号代表赋值

**任务：在SRAM中将代码从0xd0020010重定位到0xd0024000**

假设我们要完成这个任务，其实这个任务没什么实际意义，我们只是用来练习使用。

下面的是链接脚本代码

```
SECTIONS
{
	. = 0xd0024000;
	
	.text : {
		start.o
		* (.text)
	}
    		
	.data : {
		* (.data)
	}
	
	bss_start = .; 
	.bss : {
		* (.bss)
	}
	
	bss_end  = .;	
}

```



下面的是start.S 源码

```

#define WTCON		0xE2700000

#define SVC_STACK	0xd0037d80

.global _start					// 把_start链接属性改为外部，这样其他文件就可以看见_start了
_start:
	// 第1步：关看门狗（向WTCON的bit5写入0即可）
	ldr r0, =WTCON
	ldr r1, =0x0
	str r1, [r0]
	
	// 第2步：设置SVC栈
	ldr sp, =SVC_STACK
	
	// 第3步：开/关icache
	mrc p15,0,r0,c1,c0,0;			// 读出cp15的c1到r0中
	//bic r0, r0, #(1<<12)			// bit12 置0  关icache
	orr r0, r0, #(1<<12)			// bit12 置1  开icache
	mcr p15,0,r0,c1,c0,0;
	
	// 第4步：重定位
	// adr指令用于加载_start当前运行地址
	adr r0, _start  		// adr加载时就叫短加载		
	// ldr指令用于加载_start的链接地址:0xd0024000
	ldr r1, =_start // ldr加载时如果目标寄存器是pc就叫长跳转，如果目标寄存器是r1等就叫长加载	
	// bss段的起始地址
	ldr r2, =bss_start	// 就是我们重定位代码的结束地址，重定位只需重定位代码段和数据段即可
	cmp r0, r1			// 比较_start的运行时地址和链接地址是否相等
	beq clean_bss		// 如果相等说明不需要重定位，所以跳过copy_loop，直接到clean_bss
						// 如果不相等说明需要重定位，那么直接执行下面的copy_loop进行重定位
						// 重定位完成后继续执行clean_bss。

// 用汇编来实现的一个while循环
copy_loop:
	ldr r3, [r0], #4    // 源
	str r3, [r1], #4	// 目的   这两句代码就完成了4个字节内容的拷贝
	cmp r1, r2			// r1和r2都是用ldr加载的，都是链接地址，所以r1不断+4总能等于r2
	bne copy_loop

	// 清bss段，其实就是在链接地址处把bss段全部清零
clean_bss:
	ldr r0, =bss_start					
	ldr r1, =bss_end
	cmp r0, r1				// 如果r0等于r1，说明bss段为空，直接下去
	beq run_on_dram			// 清除bss完之后的地址
	mov r2, #0
clear_loop:
	str r2, [r0], #4		// 先将r2中的值放入r0所指向的内存地址（r0中的值作为内存地址），
	cmp r0, r1				// 然后r0 = r0 + 4
	bne clear_loop

run_on_dram:	
	// 长跳转到led_blink开始第二阶段
	ldr pc, =led_blink				// ldr指令实现长跳转
	
	// 从这里之后就可以开始调用C程序了
	//bl led_blink					// bl指令实现短跳转
	
// 汇编最后的这个死循环不能丢
	b .
	
```

**adr与ldr伪指令的区别**

​	ldr和adr都是伪指令，区别是ldr是长加载、adr是短加载。

重点：adr指令加载符号地址，加载的是运行时地址；ldr指令在加载符号地址时，加载的是链接地址。



上面的bss段没有进行赋值，因为bss段中的都是为0的，没有必要进行复制。所以才会有后面的那个清bss段的代码

重定位其实说白了就是代码的拷贝，将代码从SRAM中拷贝到DDR中。





# 9、DDR的初始化

这一部分对时序图等要求很高，一般有专门的人来做，但是我们要了解基本思路，同时数据手册已经写了文档，进行27的初始化操作步骤，直接从uboot中提取算了。

(1)首先，DDR初始化和SoC（准确说是和SoC中的DDR控制器）有关，也和开发板使用的DDR芯片有关，和开发板设计时DDR的连接方式也有关。

(2)S5PV210的DDR初始化步骤在SoC数据手册：1.2.1.3 DDR2这个章节。可知初始化DDR共需27个步骤。

(3)之前分析过X210的内存连接方式是：在DRAM0上连接256MB，在DRAM1上连接了256MB。所以初始化DRAM时分为2部分，第一部分初始化DRAM0，第二部分初始化DRAM1.

(4)我们的代码不是自己写的，这个代码来自于：第一，九鼎官方的uboot中；第二，参考了九鼎的裸机教程中对DDR的初始化；第三，有些参数是我根据自己理解修改过的。

设置IO端口驱动强度

因为DDR芯片和S5PV210之间是通过很多总线连接的，总线的物理表现就是很多个引脚，也就是说DDR芯片和S5PV210芯片是通过一些引脚连接的。DDR芯片工作时需要一定的驱动信号，这个驱动信号需要一定的电平水平才能抗干扰，所以需要设置这些引脚的驱动能力，使DDR正常工作。

DRAM控制器对应的引脚设置为驱动强度2X（我也不知道为什么是2X，什么时候设置成3X 4X?，这东西只能问DDR芯片厂商或者SoC厂商，我们一般是参考原厂给的代码）

DRAM port 时钟设置
phy0中有两个寄存器设置的

```
#include "s5pv210.h"

#if 1
#define DMC0_MEMCONTROL		0x00202400 	// MemControl	BL=4, 1Chip, DDR2 Type, dynamic self refresh, force precharge, dynamic power down off

#define DMC0_MEMCONFIG_0	0x20F01323	// MemConfig0	256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
#define DMC0_MEMCONFIG_1	0x30F00312	// MemConfig1		默认值

#define DMC0_TIMINGA_REF	0x00000618	// TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
#define DMC0_TIMING_ROW		0x28233287	// TimingRow	for @200MHz
#define DMC0_TIMING_DATA	0x23240304	// TimingData	CL=3
#define	DMC0_TIMING_PWR		0x09C80232	// TimingPower

#define	DMC1_MEMCONTROL		0x00202400	// MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off

#define DMC1_MEMCONFIG_0	0x40F01323	// MemConfig0	512MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
#define DMC1_MEMCONFIG_1	0x60E00312	// MemConfig1

#define DMC1_TIMINGA_REF	0x00000618	// TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4
#define DMC1_TIMING_ROW		0x28233289	// TimingRow	for @200MHz
#define DMC1_TIMING_DATA	0x23240304	// TimingData	CL=3
#define	DMC1_TIMING_PWR		0x08280232	// TimingPower

#endif

#if 0

#define DMC0_MEMCONTROL		0x00212400 	// MemControl	BL=4, 1Chip, DDR2 Type, dynamic self refresh, force precharge, dynamic power down off

#define DMC0_MEMCONFIG_0	0x20E01323	// MemConfig0	512MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
#define DMC0_MEMCONFIG_1	0x40F01323	// MemConfig1

#define DMC0_TIMINGA_REF	0x00000618	// TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
#define DMC0_TIMING_ROW		0x28233287	// TimingRow	for @200MHz
#define DMC0_TIMING_DATA	0x23240304	// TimingData	CL=3
#define	DMC0_TIMING_PWR		0x09C80232	// TimingPower

#define	DMC1_MEMCONTROL		0x00202400	// MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off

#define DMC1_MEMCONFIG_0	0x40C01323	// MemConfig0	512MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
#define DMC1_MEMCONFIG_1	0x00E01323	// MemConfig1

#define DMC1_TIMINGA_REF	0x00000618	// TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4
#define DMC1_TIMING_ROW		0x28233289	// TimingRow	for @200MHz
#define DMC1_TIMING_DATA	0x23240304	// TimingData	CL=3
#define	DMC1_TIMING_PWR		0x08280232	// TimingPower


#endif







.global sdram_asm_init

sdram_asm_init:	
	ldr	r0, =0xf1e00000
	ldr	r1, =0x0
	str	r1, [r0, #0x0]

	/* DMC0 Drive Strength (Setting 2X) */
	
	ldr	r0, =ELFIN_GPIO_BASE

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP1_0DRV_SR_OFFSET]		// 寄存器中对应0b10，就是2X

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP1_1DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP1_2DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP1_3DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP1_4DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP1_5DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP1_6DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP1_7DRV_SR_OFFSET]

	ldr	r1, =0x00002AAA
	str	r1, [r0, #MP1_8DRV_SR_OFFSET]

	
	/* DMC1 Drive Strength (Setting 2X) */
	
	ldr	r0, =ELFIN_GPIO_BASE
	
	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP2_0DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP2_1DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP2_2DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP2_3DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP2_4DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP2_5DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP2_6DRV_SR_OFFSET]

	ldr	r1, =0x0000AAAA
	str	r1, [r0, #MP2_7DRV_SR_OFFSET]

	ldr	r1, =0x00002AAA
	str	r1, [r0, #MP2_8DRV_SR_OFFSET]
	
	/* DMC0 initialization at single Type*/
	ldr	r0, =APB_DMC_0_BASE

	ldr	r1, =0x00101000				@PhyControl0 DLL parameter setting, manual 0x00101000
	str	r1, [r0, #DMC_PHYCONTROL0]

	ldr	r1, =0x00000086				@PhyControl1 DLL parameter setting, LPDDR/LPDDR2 Case
	str	r1, [r0, #DMC_PHYCONTROL1]

	ldr	r1, =0x00101002				@PhyControl0 DLL on
	str	r1, [r0, #DMC_PHYCONTROL0]

	ldr	r1, =0x00101003				@PhyControl0 DLL start
	str	r1, [r0, #DMC_PHYCONTROL0]

find_lock_val:
	ldr	r1, [r0, #DMC_PHYSTATUS]		@Load Phystatus register value
	and	r2, r1, #0x7
	cmp	r2, #0x7				@Loop until DLL is locked
	bne	find_lock_val
	
	and	r1, #0x3fc0 
	mov	r2, r1, LSL #18
	orr	r2, r2, #0x100000
	orr	r2 ,r2, #0x1000	
		
	orr	r1, r2, #0x3				@Force Value locking
	str	r1, [r0, #DMC_PHYCONTROL0]
	
#if 0	/* Memory margin test 10.01.05 */
	orr	r1, r2, #0x1				@DLL off
	str	r1, [r0, #DMC_PHYCONTROL0]
#endif
	/* setting DDR2 */
	ldr	r1, =0x0FFF2010				@ConControl auto refresh off
	str	r1, [r0, #DMC_CONCONTROL]

	ldr	r1, =DMC0_MEMCONTROL			@MemControl BL=4, 1 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
	str	r1, [r0, #DMC_MEMCONTROL]
	
	ldr	r1, =DMC0_MEMCONFIG_0			@MemConfig0 256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
	str	r1, [r0, #DMC_MEMCONFIG0]

	ldr	r1, =DMC0_MEMCONFIG_1			@MemConfig1
	str	r1, [r0, #DMC_MEMCONFIG1]

	ldr	r1, =0xFF000000				@PrechConfig
	str	r1, [r0, #DMC_PRECHCONFIG]
	
	ldr	r1, =DMC0_TIMINGA_REF			@TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
	str	r1, [r0, #DMC_TIMINGAREF]
	
	ldr	r1, =DMC0_TIMING_ROW			@TimingRow	for @200MHz
	str	r1, [r0, #DMC_TIMINGROW]

	ldr	r1, =DMC0_TIMING_DATA			@TimingData	CL=3
	str	r1, [r0, #DMC_TIMINGDATA]
	
	ldr	r1, =DMC0_TIMING_PWR			@TimingPower
	str	r1, [r0, #DMC_TIMINGPOWER]

	ldr	r1, =0x07000000				@DirectCmd	chip0 Deselect
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00020000				@DirectCmd	chip0 EMRS2
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00030000				@DirectCmd	chip0 EMRS3
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (MEM DLL on, DQS# disable)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00000542				@DirectCmd	chip0 MRS (MEM DLL reset) CL=4, BL=4
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00000442				@DirectCmd	chip0 MRS (MEM DLL unreset)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00010780				@DirectCmd	chip0 EMRS1 (OCD default)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (OCD exit)
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x07100000				@DirectCmd	chip1 Deselect
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x00120000				@DirectCmd	chip1 EMRS2
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x00130000				@DirectCmd	chip1 EMRS3
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x00110400				@DirectCmd	chip1 EMRS1 (MEM DLL on, DQS# disable)
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x00100542				@DirectCmd	chip1 MRS (MEM DLL reset) CL=4, BL=4
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x00100442				@DirectCmd	chip1 MRS (MEM DLL unreset)
	str	r1, [r0, #DMC_DIRECTCMD]
	
	ldr	r1, =0x00110780				@DirectCmd	chip1 EMRS1 (OCD default)
	str	r1, [r0, #DMC_DIRECTCMD]
		
	ldr	r1, =0x00110400				@DirectCmd	chip1 EMRS1 (OCD exit)
	str	r1, [r0, #DMC_DIRECTCMD]
		
	ldr	r1, =0x0FF02030				@ConControl	auto refresh on
	str	r1, [r0, #DMC_CONCONTROL]
		
	ldr	r1, =0xFFFF00FF				@PwrdnConfig
	str	r1, [r0, #DMC_PWRDNCONFIG]
		
	ldr	r1, =0x00202400				@MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
	str	r1, [r0, #DMC_MEMCONTROL]
	
// 上面是DRAM0初始化步骤
/*******************************************************************************************/	
// 下面是DRAM1初始化步骤，两者没有联系，是并列的。

	/* DMC1 initialization */
	ldr	r0, =APB_DMC_1_BASE
	ldr	r1, =0x00101000				@Phycontrol0 DLL parameter setting
	str	r1, [r0, #DMC_PHYCONTROL0]

	
	ldr	r1, =0x00000086				@Phycontrol1 DLL parameter setting
	str	r1, [r0, #DMC_PHYCONTROL1]
	ldr	r1, =0x00101002				@PhyControl0 DLL on
	str	r1, [r0, #DMC_PHYCONTROL0]
	ldr	r1, =0x00101003				@PhyControl0 DLL start
	str	r1, [r0, #DMC_PHYCONTROL0]
	
	
	
find_lock_val1:
	ldr	r1, [r0, #DMC_PHYSTATUS]		@Load Phystatus register value
	and	r2, r1, #0x7
	cmp	r2, #0x7				@Loop until DLL is locked
	bne	find_lock_val1
	
	and	r1, #0x3fc0 
	mov	r2, r1, LSL #18
	orr	r2, r2, #0x100000
	orr	r2, r2, #0x1000
		
	orr	r1, r2, #0x3				@Force Value locking
	str	r1, [r0, #DMC_PHYCONTROL0]
	
#if 0	/* Memory margin test 10.01.05 */
	orr	r1, r2, #0x1				@DLL off
	str	r1, [r0, #DMC_PHYCONTROL0]
#endif

	/* settinf fot DDR2 */
	ldr	r0, =APB_DMC_1_BASE

	ldr	r1, =0x0FFF2010				@auto refresh off
	str	r1, [r0, #DMC_CONCONTROL]

	ldr	r1, =DMC1_MEMCONTROL			@MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
	str	r1, [r0, #DMC_MEMCONTROL]

	ldr	r1, =DMC1_MEMCONFIG_0			@MemConfig0	512MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
	str	r1, [r0, #DMC_MEMCONFIG0]

	ldr	r1, =DMC1_MEMCONFIG_1			@MemConfig1
	str	r1, [r0, #DMC_MEMCONFIG1]

	ldr	r1, =0xFF000000
	str	r1, [r0, #DMC_PRECHCONFIG]

	ldr	r1, =DMC1_TIMINGA_REF			@TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4
	str	r1, [r0, #DMC_TIMINGAREF]

	ldr	r1, =DMC1_TIMING_ROW			@TimingRow	for @200MHz
	str	r1, [r0, #DMC_TIMINGROW]

	ldr	r1, =DMC1_TIMING_DATA			@TimingData	CL=3
	str	r1, [r0, #DMC_TIMINGDATA]

	ldr	r1, =DMC1_TIMING_PWR			@TimingPower
	str	r1, [r0, #DMC_TIMINGPOWER]


	ldr	r1, =0x07000000				@DirectCmd	chip0 Deselect
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00020000				@DirectCmd	chip0 EMRS2
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00030000				@DirectCmd	chip0 EMRS3
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (MEM DLL on, DQS# disable)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00000542				@DirectCmd	chip0 MRS (MEM DLL reset) CL=4, BL=4
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00000442				@DirectCmd	chip0 MRS (MEM DLL unreset)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00010780				@DirectCmd	chip0 EMRS1 (OCD default)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (OCD exit)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x07100000				@DirectCmd	chip1 Deselect
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00120000				@DirectCmd	chip1 EMRS2
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00130000				@DirectCmd	chip1 EMRS3
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00110440				@DirectCmd	chip1 EMRS1 (MEM DLL on, DQS# disable)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00100542				@DirectCmd	chip1 MRS (MEM DLL reset) CL=4, BL=4
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00100442				@DirectCmd	chip1 MRS (MEM DLL unreset)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00110780				@DirectCmd	chip1 EMRS1 (OCD default)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x00110400				@DirectCmd	chip1 EMRS1 (OCD exit)
	str	r1, [r0, #DMC_DIRECTCMD]

	ldr	r1, =0x0FF02030				@ConControl	auto refresh on
	str	r1, [r0, #DMC_CONCONTROL]

	ldr	r1, =0xFFFF00FF				@PwrdnConfig	
	str	r1, [r0, #DMC_PWRDNCONFIG]

	ldr	r1, =DMC1_MEMCONTROL			@MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
	str	r1, [r0, #DMC_MEMCONTROL]
	// 函数返回
	mov pc, lr
```





DDR的初始化相当复杂……，数据手册也有讲到DDR的初始化。

其实uboot中的也有DDR的初始化，我们可以直接在这个里边进行提取就行了。自己写的话要搞清楚DDR中的相关配置寄存器。



S5PV210共有2个内存端口（就好象有2个内存插槽）。再结合查阅数据手册中内存映射部分，可知：两个内存端口分别叫DRAM0和DRAM1：

​	DRAM0：内存地址范围：0x20000000～0x3FFFFFFF（512MB），对应引脚是Xm1xxxx

​	DRAM1: 内存地址范围：0x40000000～0x7FFFFFFF（1024MB），对应引脚是Xm2xxxx



**关于地址映射方面：S5PV210的DMC跟6410和2440的DMC有个重要区别，S5PV210可以控制内存地址映射，DMC0的地址空间为 0x2000,0000~0x3fff,ffff，DMC1的地址空间为0x4000,0000~0x7fff,ffff，DMC可以通过配置寄存器来使 内存芯片映射到其内存段内的适当位置。这个配置在MEMCONFIG寄存器中。**

