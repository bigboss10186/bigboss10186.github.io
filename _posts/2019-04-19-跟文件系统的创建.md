---
layout:     post
title:      根文件系统的创建
subtitle:   uboot
date:       2019-04-19
author:     BY 孟超
header-img: img/B1xcQnsN3M.jpg
catalog: 	 true
tags:
    - uboot
---

# 1、根文件系统的概述

**1、为什么需要根文件系统**

(1)init进程的应用程序在根文件系统上

(2)根文件系统提供了根目录/

(3)内核启动后的应用层配置(etc目录)在根文件系统上。几乎可以认为：发行版=内核+rootfs

(4)shell命令程序在根文件系统上。譬如ls、cd等命令

总结：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、/bin  /sbin等目录下的shell命令，还有/lib目录下的库文件等···）相配合才能工作。

**2、根文件系统的实质是什么**

(1)根文件系统是特殊用途的文件系统。

(2)根文件系统也必须属于某种文件系统格式。rootfstype=

(3)究竟文件系统是用来干嘛的。首先，存储设备（块设备，像硬盘、flash等）是分块（扇区）的，物理上底层去访问存储设备时是按照块号（扇区号）来访问的。这就很麻烦。其次，文件系统是一些代码，是一套软件，这套软件的功能就是对存储设备的扇区进行管理，将这些扇区的访问变成了对目录和文件名的访问。我们在上层按照特定的目录和文件名去访问一个文件时，文件系统会将这个目录+文件名转换成对扇区号的访问。最后，不同的文件系统的差异就在于对这些扇区的管理策略和方法不同，譬如坏块管理、碎片管理。

**3、根文件系统的形式**

镜像文件形式

(1)使用专用工具软件制作的可供烧录的镜像文件

(2)镜像中包含了根文件系统中的所有文件

(3)烧录此镜像类似于对相应分区格式化。

(4)镜像文件系统具有一定的格式，格式是内化的，跟文件名后缀是无关的。

文件夹形式

(1)根文件系统其实就是一个包含特定内容的文件夹而已

(2)根文件系统可由任何一个空文件夹添加必要文件构成而成

(3)根文件系统的雏形就是在开发主机中构造的文件夹形式的

**4、自己制作ext2格式的根文件系统**

**mke2fs介绍**

(1)mke2fs是一个应用程序，在ubuntu中默认是安装了的。这个应用程序就是用来制作ext2、ext3、ext4等格式的根文件系统的。

(2)一般用来制作各种不同格式的rootfs的应用程序的名字都很相似，类似于mkfs.xxx（譬如用来制作ext2格式的rootfs的工具叫mkfs.ext2、用来制作jffs2格式的rootfs的工具就叫mkfs.jffs2）

(3)ubuntu14.04中的mkfs.ext2等都是mke2fs的符号链接而已。

**5、动手制作ext3格式的根文件系统**

(1)创建rootfs.ext2文件并且将之挂载到一个目录下方便访问它

执行命令：

dd if=/dev/zero of=rootfs.ext2 bs=1024 count=2048

这里只是先实验一下，所以这个根文件系统我们只做成了2MB（1024 * 2048）

losetup  /dev/loop1 rootfs.ext2

mke2fs -m 0 /dev/loop1 2048

mount -t ext2 /dev/loop1 ./rootfs/

(2)我们向镜像中写入一个普通文件linuxrc。这个文件就会成为我们制作的镜像中的/linuxrc。内核挂载了这个镜像后就会尝试去执行/linuxrc。然后执行时必然会失败。我们将来实验看到的现象就应该是：挂载成功，执行/linuxrc失败。

(3)将来真正去做有用的rootfs时，就要在这一步添加真正可以执行的linuxrc程序，然后还要添加别的/lib目录下的库文件，/etc目录下的配置文件等。

(4)卸载掉，然后镜像就做好了。

umount /dev/loop1

losetup -d /dev/loop1



**6、烧录制作的rootfs.ext3**

(1)烧录过程参考刷机过程。注意bootargs传参设置，就是fastboot system  xxx/rootfs.ext3,直接烧就行

**7、nfs方式启动自制简易文件夹形式的rootfs**

首先需要搭建nfs服务器。

然后配置内核以支持nfs作为rootfs

```
1、配置网络部分，主要是使能CONFIG_IP_PNP以在2中能够看到Root file system on NFS选项
Networking support 
	Networking options 
		TCP/IP networking
				IP: kernel level autoconfiguration
					[*] IP: DHCP support
					[*] IP: BOOTP support
					
2、配置开启nfs服务
File systems  --->	
	Network File Systems  --->
		<*> NFS client support 
		[*] NFS client support for NFS version 3                                  [*] NFS client support for the NFSv3 ACL protocol extension 
		[*] NFS client support for NFS version 4 (EXPERIMENTAL) 
		[*] NFS client support for NFSv4.1 (DEVELOPER ONLY) 
		[*] Root file system on NFS  
```



(1)设置nfs启动方式的bootargs

  setenv bootargs root=/dev/nfs nfsroot=192.168.1.141:/root/porting_x210/rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off  init=/linuxrc console=ttySAC2,115200 

(2)在menuconfig中配置支持nfs启动方式

![](https://s2.ax1x.com/2019/04/17/AzgWcQ.png)


nfs方式启动相当于开发板上的内核远程挂载到主机上的rootfs，nfs方式启动不用制作rootfs镜像。nfs方式不适合真正的产品，一般作为产品开发阶段调试使用

**8、到底什么是linuxrc**

/linuxrc是一个可执行的应用程序

(1)/linuxrc是应用层的，和内核源码一点关系都没有

(2)/linuxrc在开发板当前内核系统下是可执行的。因此在ARM SoC的linux系统下，这个应用程序就是用arm-linux-gcc编译链接的；如果是在PC机linux系统下，那么这个程序就是用gcc编译连接的。

(3)/linuxrc如果是静态编译连接的那么直接可以运行；如果是动态编译连接的那么我们还必须给他提供必要的库文件才能运行。但是因为我们/linuxrc这个程序是由内核直接调用执行的，因此用户没有机会去导出库文件的路径，因此实际上这个/linuxrc没法动态连接，一般都是静态连接的。

/linuxrc执行时引出用户界面

(1)操作系统启动后在一系列的自己运行配置之后，最终会给用户一个操作界面（也许是cmdline，也许是GUI），这个用户操作界面就是由/linuxrc带出来的。

(2)用户界面等很多事并不是在/linuxrc程序中负责的，用户界面有自己专门的应用程序，但是用户界面的应用程序是直接或者间接的被/linuxrc调用执行的。用户界面程序和其他的应用程序就是进程2、3、4·····，这就是我们说的进程1（init进程，也就是/linuxrc）是其他所有应用程序进程的祖宗进程。

/linuxrc负责系统启动后的配置

(1)就好像一个房子建好之后不能直接住，还要装修一样；操作系统启动起来后也不能直接用，要配置下。

(2)操作系统启动后的应用层的配置（一般叫运行时配置，英文简写etc）是为了让我们的操作系统用起来更方便，更适合我个人的爱好或者实用性。

**/linuxrc在嵌入式linux中一般就是busybox**

(1)busybox是一个C语言写出来的项目，里面包含了很多.c文件和.h文件。这个项目可以被配置编译成各个平台下面可以运行的应用程序。我们如果用arm-linux-gcc来编译busybox就会得到一个可以在我们开发板linux内核上运行的应用程序。

(2)busybox这个程序开发出来就是为了在嵌入式环境下构建rootfs使用的，也就是说他就是专门开发的init进程应用程序。

(3)busybox为当前系统提供了一整套的shell命令程序集。譬如vi、cd、mkdir、ls等。在桌面版的linux发行版（譬如ubuntu、redhat、centOS等）中vi、cd、ls等都是一个一个的单独的应用程序。但是在嵌入式linux中，为了省事我们把vi、cd等所有常用的shell命令集合到一起构成了一个shell命令包，起名叫busybox。



**9、rootfs中还应该有什么**

(1)最重要的就是上节课讲过的/linuxrc

(2)dev目录下的设备文件。在linux中一切皆是文件，因此一个硬件设备也被虚拟化成一个设备文件来访问，在linux系统中/dev/xxx就表示一个硬件设备，我们要操作这个硬件时就是open打开这个设备文件，然后read/write/ioctl操作这个设备，最后close关闭这个设备。

在最小rootfs中/dev目录也是不可少的，这里面有一两个设备文件是rootfs必须的。

(3)sys和proc目录。在最小rootfs中也是不可省略的，但是这两个只要创建了空文件夹即可，里面是没东西的，也不用有东西。这两个目录也是和驱动有关的。属于linux中的虚拟文件系统。

(4)usr是系统的用户所有的一些文件的存放地，这个东西将来busybox安装时会自动生成。

(5)etc目录是很关键很重要的一个，目录中的所有文件全部都是运行时配置文件。/etc目录下的所有配置文件会直接或者间接的被/linuxrc所调用执行，完成操作系统的运行时配置。etc目录是制作rootfs的关键，后面专门写一下这个。

(6)lib目录也是rootfs中很关键的一个，不能省略的一个。lib目录下放的是当前操作系统中的动态和静态链接库文件。我们主要是为了其中的动态链接库。

**10、VFS简介**

什么是VFS

(1)VFS是linux内核的一种设计理念、设计机制。VFS就是vitrual file system，叫虚拟文件系统。

(2)具体的一些文件系统如FAT、NTFS、ext2、ext3、jffs2、yaffs2、ubi等主要设计目的是为了管理块设备（硬盘、Nand···）

(3)VFS是借鉴了文件系统的设计理念（通过文件系统将底层难以管理的物理磁盘扇区式访问，转换成目录+文件名的方式来访问），将硬件设备的访问也虚拟化成了对目录+文件的访问。所以有了VFS后我们可以通过设备文件（目录+文件名，譬如/dev/mmcblk0p2）的方式来访问系统中的硬件设备。

(4)以上可以初步看出VFS的一些厉害之处，但是VFS不止于此。



# 2、根文件系统的制作

**busybox的移植**

**1、busybox源码下载**

(1)busybox是一个开源项目，所以源代码可以直接从网上下载。

(2)busybox的版本差异不大，版本新旧无所谓。

(3)下载busybox可以去linuxidc等镜像网站，也可以去www.busybox.net官方网站下载。

**2、修改Makefile**

(1) ARCH = arm

(2) CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin//arm-none-linux-gnueabi-

**3、make menuconfig进行配置**

Busybox Settings--->

​	Build Options--->

​		[*]Build BusyBox as a static binary(no shared libs)



Busybox Library Tuning--->

​	[*]vi-style line editing commands

​	[*]Fancy shell prompts




Linux Module Utilities--->

​	[ ]Simplified modutils

​	[*]insmod

​	[*]rmmod

​	[*]lsmod

​	[*]modprob

​	[*]depmod





Linux System Utilities--->[*]mdev

​	[*]Support /etc/mdev.conf

​	[*]Support subdirs/symlinks

​	[*]Support regular expressions substitutions when renaming dev

​	[*]Support command execution at device addition/removal

​	[*]Support loading of firmwares



**4、make 然后 make install**

(1)make编译，如果有错误解决之

(2)make install执行的时候其实是在执行busybox顶层目录下的一个目标install。

(3)make install在所有的linux下的软件中作用都是安装软件。在传统的linux系统中安装软件时都是选择源代码方式安装的。我们下载要安装的软件源代码，然后配置、编译、安装。make install的目的就是将编译生成的可执行程序及其依赖的库文件、配置文件、头文件安装到当前系统中指定（一般都可以自己指定安装到哪个目录下，如果不指定一般都有个默认目录）的目录下。我们需要自己设置安装路径，先用make menuconfig 然后在busybox setting中，再进入installation options中，然后手动输入文件安装位置保存并退出即可。

**5、设置bootargs挂载添加了busybox移植的rootfs**

(1)之前建立了一个空的文件夹然后自己touch linuxrc随便创建了一个不能用的/linuxrc然后去nfs挂载rootfs，实验结果是：挂载成功，执行/linuxrc失败。

(2)现在我们移植了busybox后/linuxrc就可以用了，然后再次去nfs挂载这个rootfs。预计看到的效果是：挂载成功，执行/linuxrc也能成功。

(3)注意uboot的bootargs设置成：setenv bootargs root=/dev/nfs nfsroot=192.168.1.141:/root/porting_x210/rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off  init=/linuxrc console=ttySAC2,115200 

(4)实验结果：挂载成功，执行/linuxrc（也就是busybox）成功，但是因为找不到/etc/init.d/rcS和/dev/tty2等文件所以一直在打印错误提示信息，但是其实有进入命令行。

**6、inittab详解**

```
#first:run the system script file

::sysinit:/etc/init.d/rcS

::askfirst:-/bin/sh

::ctrlaltdel:-/sbin/reboot

#umount all filesystem

::shutdown:/bin/umount -a -r

#restart init process

::restart:/sbin/init

```



添加一个典型的inittab

(1)将我提供的典型的inittab文件复制到我们制作的rootfs的根目录下的/etc/目录下

(2)再次启动内核挂载这个rootfs看效果

(3)实验现象是成功启动并且挂载rootfs进入了控制台命令行。当前制作的最小rootfs成功了

**7、inittab格式解析**

(1)inittab的工作原理就是被/linuxrc（也就是busybox）执行时所调用起作用。

(2)inittab在/etc目录下，所以属于一个运行时配置文件，是文本格式的（内容是由一系列的遵照一个格式组织的字符组成的），实际工作的时候busybox会（按照一定的格式）解析这个inittab文本文件，然后根据解析的内容来决定要怎么工作。

(3)busybox究竟如何完成解析并且解析结果如何去工作（busybox中实现/etc/inittab的原理）并不是我们的目标，我们的重点是inittab的格式究竟怎样的？我们看到一个inittab后怎么去分析这个inittab对启动的影响。

(4)inittab的格式在busybox中定义的，网上可以搜索到详细的格式说明，具体去参考即可：

第一个：#开始的行是注释

第二个：冒号在里面是分隔符，分隔开各个部分。

第三个：inittab内容是以行为单位的，行与行之间没有关联，每行都是一个独立的配置项，每一个配置项表示一个具体的含义。

第四个：每一行的配置项都是由3个冒号分隔开的4个配置值共同确定的。这四个配置值就是id:runlevels:action:process。值得注意得是有些配置值可以空缺，空缺后冒号不能空缺，所以有时候会看到连续2个冒号。

第五个：每一行的配置项中4个配置值中最重要的是action和process，action是一个条件/状态，process是一个可被执行的程序的pathname。合起来的意思就是：当满足action的条件时就会执行process这个程序。

注意：理解inittab的关键就是明白“当满足action的条件时就会执行process这个程序。” 你去分析busybox的源代码就会发现，busybox最终会进入一个死循环，在这个死循环中去反复检查是否满足各个action的条件，如果某个action的条件满足就会去执行对应的process。

第六个：明白各个action什么意思

**8、rcS文件介绍**

```shell
#!/bin/sh

PATH=/sbin:/bin:/usr/sbin:/usr/bin

runlevel=S

prevlevel=N

umask 022

export PATH runlevel prevlevel

mount -a

echo /sbin/mdev > /proc/sys/kernel/hotplug

mdev -s

/bin/hostname -F /etc/sysconfig/HOSTNAME

ifconfig eth0 192.168.1.10

```



/etc/init.d/rcS文件是linux的运行时配置文件中最重要的一个，其他的一些配置都是由这个文件引出来的。这个文件可以很复杂也可以很简单，里面可以有很多的配置项。

1、PATH=xxx

(1)首先从shell脚本的语法角度分析，这一行定义了一个变量PATH，值等于后面的字符串

(2)后面用export导出了这个PATH，那么PATH就变成了一个环境变量。

(3)PATH这个环境变量是linux系统内部定义的一个环境变量，含义是操作系统去执行程序时会默认到PATH指定的各个目录下去寻找。如果找不到就认定这个程序不存在，如果找到了就去执行它。将一个可执行程序的目录导出到PATH，可以让我们不带路径来执行这个程序。

(4)rcS中为什么要先导出PATH？就是因为我们希望一旦进入命令行下时，PATH环境变量中就有默认的/bin /sbin /usr/bin /usr/sbin 这几个常见的可执行程序的路径，这样我们进入命令行后就可以ls、cd等直接使用了。

(5)为什么我们的rcS文件还没添加，系统启动就有了PATH中的值？原因在于busybox自己用代码硬编码为我们导出了一些环境变量，其中就有PATH。

2、runlevel=

(1)runlevel也是一个shell变量，并且被导出为环境变量。

(2)runlevel这个环境变量到底有什么用？

(3)runlevel=S表示将系统设置为单用户模式

3、umask=

(1)umask是linux的一个命令，作用是设置linux系统的umask值。

(2)umask值决定当前用户在创建文件时的默认权限。

4、mount -a

(1)mount命令是用来挂载文件系统的

(2)mount -a是挂载所有的应该被挂载的文件系统，在busybox中mount -a时busybox会去查找一个文件/etc/fstab文件，这个文件按照一定的格式列出来所有应该被挂载的文件系统（包括了虚拟文件系统）



在实际使用这个文件时：

(1)我们发现rcS文件明明存在但是却提示不存在，问题原因就是rcS文件在windows下创建的，行尾换行符为'\r\n'，多了点东西。但是因为ubuntu中的vi对行尾做了优化，所以在ubuntu中是看不出来多了东西的。但是在securecrt下一看就发现每一行末尾多出来了一个^M。

(2)这个例子告诉我们：shell脚本文件如果格式不对，运行时可能会被提示文件不存在。

(3)扩展讲一个：有时候一个应用程序执行时也会提示文件不存在，问题可能是这个程序所调用的一个动态链接库找不到。

(4)测试结果：PATH本来在busybox中就已经用代码导出过了，所以rcS中再次导出没有任何明显的现象，因此看不出什么差别；runlevel实际执行结果一直是unknown，问题在于busybox并不支持runlevel这个特性。



mount测试

(1)挂载时全部出错：
mount: mounting proc on /proc failed: No such file or directory

mount: mounting sysfs on /sys failed: No such file or directory

mount: mounting tmpfs on /var failed: No such file or directory

mount: mounting tmpfs on /tmp failed: No such file or directory

mount: mounting tmpfs on /dev failed: No such file or directory

(2)原因是因为根文件系统中找不到挂载点。所谓挂载点就是我们要将目标文件系统（当然这里都是虚拟文件系统）挂载到当前文件系统中的某一个目录中，这个目录就是挂载点。

(3)解决方案就是自己在制作的rootfs根目录下创建这些挂载点目录即可。

(4)验证是否挂载成功，可以看挂载时输出信息；还可以启动后去看proc和sys文件夹，如果有文件出现则证明挂载成功了，如果没东西就证明失败了。

5、mdev

(1)mdev是udev的嵌入式简化版本，udev/mdev是用来配合linux驱动工作的一个应用层的软件，udev/mdev的工作就是配合linux驱动生成相应的/dev目录下的设备文件。

(2)因为这个问题涉及到驱动，因此详细讲解要等到驱动部分。这里我们只是通过一些直观的现象来初步理解udev/mdev的工作效果。

(3)在rcS文件中没有启动mdev的时候，/dev目录下启动后是空的；在rcS文件中添加上mdev有关的2行配置项后，再次启动系统后发现/dev目录下生成了很多的设备驱动文件。

(4)/dev目录下的设备驱动文件就是mdev生成的，这就是mdev的效果和意义。

6、hostname

(1)hostname是linux中的一个shell命令。命令（hostname xxx）执行后可以用来设置当前系统的主机名为xxx，直接hostname不加参数可以显示当前系统的主机名。

(2)/bin/hostname -F /etc/sysconfig/HOSTNAME -F来指定了一个主机名配置文件（这个文件一般文件名叫hostname或者HOSTNAME）

7、ifconfig

(1)有时候我们希望开机后进入命令行时ip地址就是一个指定的ip地址（譬如192.168.1.30），这时候就可以在rcS文件中ifconfig eth0 192.168.1.30

**9、profile文件和用户登录理论**

1、profile文件添加

(1)之前添加了/bin/hostname在/etc/sysconfig/HOSTNAME文件中定义了一个hostname（aston210），实际效果是：命令行下hostname命令查到的host名字确实是aston210。但是问题就是命令行的提示符是没有显示的。

(2)这个问题的解决就要靠profile文件。将提供的profile文件放入/etc/目录下即可。

(3)添加了之后的实验现象：命令行提示符前面显示：[@aston210 ]#

结论是：第一，profile文件起了作用，hostname显示出来了。第二，还有个问题，登录用户名没显示出来。原因就是我们直接进入了命令行而没有做登录。等我们添加了用户登录功能，并且成功登陆后这个问题就能解决。

(4)profile文件工作原理是：profile文件也是被busybox（init进程）自动调用的，所以是认名字的。

2、如何看到用户登录界面

(1)linux中有一个原则就是用一个小程序来完成一个功能。如果我们产品确实需要很复杂的综合型的功能，我们倾向于先使用很多个小程序完成其中的一个功能，然后再将这些小程序集成起来完成整个大功能的产品。

(2)这种集成很多个小程序来完成一个大的功能，有很多种技术实现。譬如shell脚本，还有一些别的技术，譬如linux启动中的inittab。

(3)因为我们之前intttab中有一个配置项 ::askfirst:-/bin/sh，这个配置项作用就是当系统启动后就去执行/bin/sh，执行这个就会出现命令行。因此我们这样的安排就会直接进入命令行而不会出现登录界面。

(4)我们要出现登录界面，就不能直接执行/bin/sh，而应该执行一个负责出现登录界面并且负责管理用户名和密码的一个程序，busybox中也集成了这个程序（就是/bin/login和/sbin/gettty），因此我们要在inittab中用/bin/login或者/sbin/getty去替代/bin/sh。

3、用户名和密码的设置

(1)用户名和密码的设置是和登录程序有关联的，但是/bin/login和/sbin/getty在用户名和密码的管理上是一样的。其实常见的所有的linux系统的用户名和密码的管理几乎都是一样的。

(2)密码一般都是用加密文字的，而不是用明文。意思就是系统中的密码肯定是在系统中的一个专门用来存密码的文件中存储的，用明文存密码有风险，因此linux系统都是用密文来存储密码的。关于密文密码的使用下节课实践时会详细讲。

4、用户登录实战

添加/bin/login到sysinit

(1)在inittab中修改，去掉/bin/sh，换上/bin/login，则系统启动后出现登录界面。可以输入用户名和密码。

(2)实验现象：成功出现用户登录界面，但是死活密码不对。

5、添加passwd和shadow文件

(1)为什么用户名和密码不对？因为我们根本没有为root用户设置密码。

(2)linux系统中用来描述用户名和密码的文件是passwd和shadow文件，这两个文件都在etc目录下。passwd文件中存储的是用户的密码设置，shadow文件中存储的是加密后的密码。

(3)我们直接复制ubuntu系统中的/etc/passwd和/etc/shadow文件到当前制作的rootfs目录下，然后再做修改即可。

(4)/etc/passwd和/etc/shadow修理好后，shadow中默认有一个加密的密码口令，这个口令和你拷贝的shadow本身有关，像我的ubuntu中root用户的密码就是root，因此复制过来后登陆时的密码还是root。

6、重置密码实践

(1)ubuntu刚装好的时候默认登录是用普通用户登录的，默认root用户是关闭的。普通用户的密码是在装系统的时候设置的，普通用户登陆后可以使用su passwd root给root用户设置密码，设置了密码后root用户才可以登录。

(2)其实这个原因就是root用户在/etc/shadow文件中加密口令是空白的。所以是不能登录的。

(3)busybox中因为没有普通用户，所以做法是：默认root用户如果加密口令是空的则默认无密码直接登录。等我们登陆了之后还是可以用passwd root给root用户设置密码。

(4)平时有时候我们忘记了自己的操作系统的密码，怎么办？有一种解决方法就是用其他系统（WindowsPE系统或者ubuntu的单用户模式等···）来引导启动，启动后挂载到我们的硬盘上，然后找到/etc/shadow文件，去掉密文密码后保存。然后再重启系统后密码就没了。

**10、动态链接库的拷贝**

1、静态编译链接helloworld程序并执行

(1)任务：自己写一个helloworld程序，然后交叉编译连接，然后丢到开发板根文件系统中，开机后去运行。

(2)C程序如果使用gcc来编译则可以在主机ubuntu中运行，但是不能在开发板运行；要在开发板运行需要用arm-linux-gcc来交叉编译，但是这时候就不能在主机ubuntu中运行了。我们可以用file xx命令来查看一个elf可执行程序是哪个架构的。

(3)静态链接：arm-linux-gcc hello.c -o hello_satic -static

(4)实验结果：静态编译连接后生成的hello_satic已经可以成功运行。

2、动态编译连接helloworld程序并执行

(1)动态链接：arm-linux-gcc hello.c -o hello_dynamic

(2)实验结果：-sh: ./hello_dynamic: not found运行时提示找不到程序。

(3)错误分析：动态连接的hello程序中调用到了printf函数，而printf函数在动态连接时要在运行时环境（开发板的rootfs）中去寻找对应的库文件（开发板rootfs中部署的动态链接库中包含了printf函数的那个库文件）。如果找到了则printf函数就会被成功解析，然后hello_dynamic程序就会被执行；如果找不到则程序就不能被执行，命令行会提示错误信息-sh: ./hello_dynamic: not found

(4)解决方案：将arm-linux-gcc的动态链接库文件复制到开发板rootfs的/lib目录下即可解决。

3、找到并复制动态链接库文件到rootfs中

(1)我们用的arm-2009q3这个交叉编译工具链的动态链接库在/usr/local/arm/arm-2009q3/arm-none-linux-gnueabi/libc/lib目录下。其他的一些交叉编译工具链中动态链接库的目录不一定在这里，要去找一下。找的方法就是find

(2)复制动态链接库到roots/lib目录下。复制时要注意参数用-rdf，主要目的就是符号链接复制过来还是符号链接。
复制命令：cp lib/*so* /root/porting_x210/rootfs/rootfs/lib/ -rdf

(3)现在再去测试./hello_dynamic看看是否可以运行，实验结果是可以运行。

4、使用strip工具去掉库中符号信息

动态链接库so文件中包含了调试符号信息，这些符号信息在运行时是没用的（调试时用的），这些符号会占用一定空间。在传统的嵌入式系统中flash空间是有限的，为了节省空间常常把这些符号信息去掉。这样节省空间并且不影响运行。

去掉符号命令：arm-linux-strip *so*

实际操作后发现库文件由3.8M变成了3.0M，节省了0.8M的空间。



**12、开机自启动与主流rcS格式介绍**

1、修改rcS实现开机自启动

(1)开机自启动指的是让一些应用程序能够开机后自动执行

(2)开机自启动的实现原理就是在开机会自动执行的脚本rcS中添加上执行某个程序的语句代码即可

2、前台运行与后台运行

(1)程序运行时占用了当前的控制台，因此这个程序不结束我们都无法使用控制台，这就叫前台运行。默认执行程序就是前台运行的。

(2)后台运行就是让这个程序运行，并且同时让出控制台。这时候运行的程序还能照常运行而且还能够不影响当前控制台的使用。

(3)让一个程序后台运行的方法就是 ./xxx &

3、开机装载驱动等其他开机自动执行

4、实际开发中rootfs的rcS是怎样的

(1)我们以X210开发板九鼎科技做的rootfs中rcS部分来分析

(2)分析inittab发现：sysinit执行rcS，shutdown时执行rcK。

(3)分析/etc/init.d/rcS和rcK文件发现，rcS和rcK都是去遍历执行/etc/init.d/目录下的S开头的脚本文件，区别是rcS传参是start，rcK传参是stop。

(4)由此可以分析出来，正式产品中的rcS和rcK都是一个引入，而不是真正干活的。真正干活的配置脚本是/etc/init.d/S??*。这些文件中肯定有一个判断参数是start还是stop，然后start时去做一些初始化，stop时做一些清理工作。

**13、制作ext2格式的镜像并烧录启动**

1、确定文件夹格式的rootfs可用

(1)设置bootargs为nfs启动方式，然后从主机ubuntu中做好的文件夹格式的rootfs去启动，然后看启动效果，作为将来的参照物。

2、动手制作ext2格式的镜像

(1)

dd if=/dev/zero of=rootfs.ext2 bs=1024 count=10240

losetup  /dev/loop1 rootfs.ext2

mke2fs -m 0 /dev/loop1 10240

mount -t ext2 /dev/loop1 ./ext2_rootfs/

(2)向./rootfs中复制内容，用cp ../rootfs/* ./ -rf

(3)umount /dev/loop1

losetup -d /dev/loop1

(4)完成后得到的rootfs.ext2就是我们做好的rootfs镜像。拿去烧录即可。



**14、烧录镜像并设置合适的bootargs**
(1)使用fastboot烧录制作好的rootfs.ext2到开发板inand中

fastboot flash system rootfs.ext2

烧录完成后重启系统

(2)设置bootargs为：set bootargs console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext2

(3)启动后发现现象和之前nfs方式启动挂载rootfs后一样的，至此rootfs制作实验圆满完成。

