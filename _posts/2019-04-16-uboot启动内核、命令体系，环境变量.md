---
layout:     post
title:      uboot启动内核、命令体系、环境变量
subtitle:   uboot
date:       2019-04-16
author:     BY 孟超
header-img: img/SyxnyrgH3M.jpg
catalog: 	 true
tags:
    - uboot
---



uboot和linux都可以算是一个裸机程序，只不过是一个比较复杂庞大的裸机程序。

uboot执行完毕之后，如果没有按下回车，则会自动执行bootcmd命令：**bootcmd=movi read kernel 30008000; movi read rootfs 30B00000 300000; bootm 30008000 30B00000**直接启动内核。接下来看看我们需要怎么样来启动内核并且内核是怎么样启动成功的。

其实我们还需要设置bootargs，bootargs也是一个环境变量。只不过是一个比较重要的环境变量。bootargs是用来个Linux内核传递的参数。可以现在uboot命令行底下使用printenv命令打印这些环境变量来查看。比如我们这里使用的是**bootargs = console = ttySAC2,115200 root = /dev/mmcblk0p2 rw  init = /linuxrc rootfstype = ext2**

# 1、启动linux内核

上面说的用bootcmd启动内核，上面的命令是内核已经在SD卡中了，才能执行成功上面的命令。如果我们使用tftp方式进行下载的话（以远端的服务器获取镜像进行下载），可以修改该bootcmd命令，使其自动执行bootcmd命令的时候是直接执行的tftp命令下载。

将kernel弄到DDR特定位置之后（我们这里的特定位置是DDR中的30008000），可以用bootm 30008000进行跳转执行内核。

**镜像要放在DDR的什么地址？**

内核一定要放在链接地址处，**链接地址去内核源代码的链接脚本或者Makefile中去查找**。X210中是0x30008000。

**什么是vmlinuz和zImage和uImage**

(1)uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是可以直接执行的。但是这种格式不能用来烧录下载。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的）得到的。这个u-boot. bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。

(2)linux内核经过编译后也会生成一个elf格式的可执行程序，叫vmlinux或vmlinuz，这个就是原始的未经任何处理加工的原版内核elf文件；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫Image（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。

(3)原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的前端附加了一部分解压缩代码。构成了一个压缩格式的镜像就叫zImage。（因为当年Image大小刚好比一张 软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。

(4)uboot为了启动linux内核，还发明了一种内核格式叫uImage。uImage是由zImage加工得到的，uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。这个加工过程其实就是在zImage前面加上64字节的uImage的头信息即可。

(4)原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。但是所有的uboot肯定都支持uImage启动。



# 2、zImage启动细节分析

**LINUX_ZIMAGE_MAGIC**

(1)这个是一个定义的魔数，这个数等于0x016f2818，表示这个镜像是一个zImage。也就是说zImage格式的镜像中在头部的一个固定位置存放了这个数作为格式 标记。如果我们拿到了一个image，去他的那个位置去取4字节判断它是否等于LINUX_ZIMAGE_MAGIC，则可以知道这个镜像是不是一个zImage。

(2)命令 bootm 0x30008000，所以do_boom的argc=2，argv[0]=bootm  argv[1]=0x30008000。但是实际bootm命令还可以不带参数执行。如果不带参数直接bootm，则会从CFG_LOAD_ADDR地址去执行（定义在x210_sd.h中）。

(3)zImage头部开始的第37-40字节处存放着zImage标志魔数，从这个位置取出然后对比LINUX_ZIMAGE_MAGIC。可以用二进制阅读软件来打开zImage查看，就可以证明。很多软件都可以打开二进制文件，如winhex、UltraEditor。

**image_header_t**

(1)这个数据结构是我们uboot启动内核使用的一个标准启动数据结构，zImage头信息也是一个image_header_t，但是在实际启动之前需要进行一些改造。

hdr->ih_os = IH_OS_LINUX;

hdr->ih_ep = ntohl(addr);

这两句就是在进行改造。

(2)images全局变量是do_bootm函数中使用，用来完成启动过程的。zImage的校验过程其实就是先确认是不是zImage，确认后再修改zImage的头信息到合适，修改后用头信息去初始化images这个全局变量，然后就完成了校验。

uImage启动和设备树方式启动这里不详细讲。

# 3、do_bootm函数的分析

我们时这么使用bootm命令的：bootm 0x30008000

走的是addr = simple_strtoul(argv[1], NULL, 16)；

addr中的值为0x30008000

接下来判断0x30008000右偏移36字节以后，这个地址中的值如果为 0x016f2818这个魔数的话，说明启动镜像为zImage则 输出boot with zImage，

hdr应该是镜像zImage的头信息



 ```c
hdr->ih_os = IH_OS_LINUX;　　　　　
//zImage header中 IH_os 赋值为 IH_OS_LINUX；
　　
hdr->ih_ep = ntohl(addr);　　　
//ih_ep 中存放的是point address 这个值实际上就是真正内核代码的地址；
 ```



在看下面这句代码

`memmove (&images.legacy_hdr_os_copy, hdr, sizeof(image_header_t));`

把hdr中的值复制一份到 image.legacy_hdr_os_copy中，即把内存地址0x30008000处设置好的zImage头复制一份到uboot的data段，因为static bootm_headers_t images; images为uboot内定义的一个bootm_header_t格式的全局变量；看一下bootm_header_t类型为一个结构体，包含一个image_header_t类型的指针，这个指针最后指向了0x30008000处的zImage header还包含一个image_header_t类型的结构体，就是用上面那句代码把0x30008000处的zImage header在酯类复制了一份；还包含一个标志位 legacy_hdr_valid如果上面两个赋值以后，把legacy_hdr_valid赋值为1；

```c
typedef struct bootm_headers {
    
    image_header_t    *legacy_hdr_os;    
    
    /* image header pointer */
    
    image_header_t    legacy_hdr_os_copy;   

    /* header copy */
     
    ulong        legacy_hdr_valid;
    
}
```



```c
typedef struct image_header {
    uint32_t    ih_magic;    /* Image Header Magic Number    */
    
    uint32_t    ih_hcrc;    /* Image Header CRC Checksum    */
    
    uint32_t    ih_time;    /* Image Creation Timestamp    */
    
    uint32_t    ih_size;    /* Image Data Size        */
    
    uint32_t    ih_load;    /* Data     Load  Address        */
    
    uint32_t    ih_ep;        /* Entry Point Address        */
    
    uint32_t    ih_dcrc;    /* Image Data CRC Checksum    */
    
    uint8_t        ih_os;        /* Operating System        */
    
    uint8_t        ih_arch;    /* CPU architecture        */
    
    uint8_t        ih_type;    /* Image Type            */
    
    uint8_t        ih_comp;    /* Compression Type        */
    
    uint8_t        ih_name[IH_NMLEN];    /* Image Name        */
    
} image_header_t;

```





```c
#ifdef CONFIG_ZIMAGE_BOOT

#define LINUX_ZIMAGE_MAGIC    0x016f2818

    /* find out kernel image address */

    if (argc < 2) {
        
        addr = load_addr;
        
        debug ("*  kernel: default image load address = 0x%08lx\n",
               
                load_addr);
        
    } else {
        
        addr = simple_strtoul(argv[1], NULL, 16);
        
        debug ("*  kernel: cmdline image address = 0x%08lx\n", img_addr);
        
    }



    if (*(ulong *)(addr + 9*4) == LINUX_ZIMAGE_MAGIC) {
        
        printf("Boot with zImage\n");
        
        addr = virt_to_phys(addr);
        
        hdr = (image_header_t *)addr;
        
        hdr->ih_os = IH_OS_LINUX;
        
        hdr->ih_ep = ntohl(addr);

        memmove (&images.legacy_hdr_os_copy, hdr, sizeof(image_header_t));

        /* save pointer to image header */
        
        images.legacy_hdr_os = hdr;

        images.legacy_hdr_valid = 1;

        goto after_header_check;
        
    }

#endif
```

直接跳转到after_header_check处，os为IH_OS_LINUX（Linux）然后调用do_bootm_linux函数；

do_bootm_linux (cmdtp, flag, argc, argv, &images);下面看一下do_bootm_linux都做了哪些事情

```c
#ifdef CONFIG_CMDLINE_TAG

    char *commandline = getenv ("bootargs");

#endif
```

首先获取环境变量bootargs：

```c
if (images->legacy_hdr_valid) {
    
        ep = image_get_ep (&images->legacy_hdr_os_copy)

else {
    
		puts ("Could not find kernel entry point!\n");
    
		goto error;
    
	}
```

在判断全局变量images中的legacy_hdr_valid是否为1，如果为1 获取ep 值；如果为1读出ep的值，如果不为1则erro

```c
theKernel = (void (*)(int, int, uint))ep;

    s = getenv ("machid");

    if (s) {
        
        machid = simple_strtoul (s, NULL, 16);
        
        printf ("Using machid 0x%x from environment\n", machid);
        
    }
```

把ep强制类型换换为函数指针类型复制给thekernel；

从环境变量中读取machid的值，赋值给s，如果s不空 则machid = 环境变量中machid的值，并打印machid；在看一下uboot如何给内核传参：  传参主要是uboot把与硬件有关的信息传给linux内核，如memory信息几bank size 起始地址、命令行信息、lcd 串口、initrd、MTD等信息

**镜像的entrypoint**

(1)ep就是entrypoint的缩写，就是程序入口。一个镜像文件的起始执行部分不是在镜像的开头（镜像开头有n个字节的头信息），真正的镜像文件执行时第一句代码在镜像的中部某个字节处，相当于头是有一定的偏移量的。这个偏移量记录在头信息中。

(2)一般执行一个镜像都是：第一步先读取头信息，然后在头信息的特定地址找MAGIC_NUM，由此来确定镜像种类；第二步对镜像进行校验；第三步再次读取头信 息，由特定地址知道这个镜像的各种信息（镜像长度、镜像种类、入口地址）；第四步就去entrypoint处开始执行镜像。

(3)theKernel = (void (*)(int, int, uint))ep;将ep赋值给theKernel，则这个函数指向就指向了内存中加载的OS镜像的真正入口地址（就是操作系统的第一句执行的代码）。

**机器码的再次确定**

uboot在启动内核时，机器码要传给内核。uboot传给内核的机器码是怎么确定的？第一顺序备选是环境变量machid，第二顺序备选是gd->bd->bi_arch_num（x210_sd.h中硬编码配置的）



# 4、传参详解

传参部分就在do_bootm_linux函数中的一部分。这里我们单独拿出来讲解一番

首先说明的是uboot和Linux传参的方式是以tag方式进行的，tag是一种数据结构。`strcut tag`在uboot和Linux kernel中都有定义。参数是uboot事先放在内存中的一个位置，并以tag方式存放。最终由kernel去拿。而且我们这里有好多tag



**tag这个结构体的定义（可以查看一下源代码，马上就明白了）**

(1)tag_header和tag_xxx。tag_header中有这个tag的size和类型编码，kernel拿到一个tag后先分析tag_header得到tag的类型和大小，然后将tag中剩余部分当作一个tag_xxx来处理。

(2)tag_start与tag_end。kernel接收到的传参是若干个tag构成的，这些tag由tag_start起始，到tag_end结束。

(3)tag传参的方式是由linux kernel发明的，kernel定义了这种向我传参的方式，uboot只是实现了这种传参方式从而可以支持给kernel传参。

**x210_sd.h中配置传参宏**

(1)CONFIG_SETUP_MEMORY_TAGS，tag_mem，传参内容是内存配置信息。

**(2)CONFIG_CMDLINE_TAG，tag_cmdline，传参内容是启动命令行参数，也就是uboot环境变量的bootargs.**

(3)CONFIG_INITRD_TAG

(4)CONFIG_MTDPARTITION，传参内容是iNand/SD卡的分区表。

(5)起始tag是ATAG_CORE、结束tag是ATAG_NONE，其他的ATAG_XXX都是有效信息tag。

**思考：内核如何拿到这些tag？**

uboot最终是调用theKernel函数来执行linux内核的，uboot调用这个函数（其实就是linux内核）时传递了3个参数。这3个参数就是uboot直接传递给linux内核的3个参数，通过寄存器来实现传参的。（第1个参数就放在r0中，第二个参数放在r1中，第3个参数放在r2中）第1个参数固定为0，第2个参数是机器码，第3个参数传递的就是大片传参tag的首地址。









# 5、uboot的命令体系

uboot中每一个命令对应一个函数，比如fastboot命令就对应的函数是do_fastboot函数。

uboot的命令体系就是一个死循环

**uboot命令解析和执行过程分析**

**从main_loop说起**

(1)uboot启动的第二阶段，在初始化了所有该初始化的东西后，进入了一个死循环，死循环的循环体就是main_loop。

(2)main_loop函数执行一遍，就是一个获取命令、解析命令、执行命令的过程。

(3)run_command函数就是用来执行命令的函数。

**run_command函数详解**

(1)控制台命令获取

(2)命令解析。parse_line函数把”md 30000000 10”解析成argv[0]=md, argv[1]=30000000 argv[2]=10;

(3)命令集中查找命令。find_cmd(argv[0])函数去uboot的命令集合当中搜索有没有argv[0]这个命令，

(4)执行命令。最后用函数指针的方式调用执行了对应函数。

**uboot中也可以自己添加命令，非常方便简答**

# 6、uboot中的环境变量

**环境变量的优先级**

(1)uboot代码当中有一个值，环境变量中也有一个值。uboot程序实际运行时规则是：如果环境变量为空则使用代码中的值；如果环境变量不为空则优先使用环境变量对应的值。

(2)譬如machid（机器码）。uboot中在x210_sd.h中定义了一个机器码2456，写死在程序中的不能更改。如果要修改uboot中配置的机器码，可以修改x210_sd.h中的机器码，但是修改源代码后需要重新编译烧录，很麻烦；比较简单的方法就是使用环境变量machid。set machid 0x998类似这样，有了machid环境变量后，系统启动时会优先使用machid对应的环境变量，这就是优先级问题。

**环境变量原理**

(1)默认环境变量，在uboot/common/env_common.c中default_environment，这东西本质是一个字符数组，大小为CFG_ENV_SIZE（16kb），里面内容就是很多个环境变量连续分布组成的，每个环境变量最末端以’\0’结束。

(2)SD卡中环境变量分区，在uboot的raw分区中。SD卡中其实就是给了个分区，专门用来存储而已。存储时其实是把DDR中的环境变量整体的写入SD卡中分区里。所以当我们saveenv时其实整个所有的环境变量都被保存了一遍，而不是只保存更改了的。

(3)DDR中环境变量，在default_environment中，实质是字符数组。在uboot中其实是一个全局变量，链接时在数据段，重定位时default_environment就被重定位到DDR中一个内存地址处了。这个地址处这个全局字符数组就是我们uboot运行时的DDR中的环境变量了。

总结：刚烧录的系统中环境变量分区是空白的，uboot第一次运行时加载的是uboot代码中自带的一份环境变量，叫默认环境变量。我们在saveenv时DDR中的环境变量会被更新到SD卡中的环境变量中，就可以被保存下来，下次开机会在环境变量relocate时会SD卡中的环境变量会被加载到DDR中去。