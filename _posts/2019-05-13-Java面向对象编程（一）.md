---
layout:     post
title:      Java面向对象编程（一）
subtitle:   Java
date:       2019-05-13
author:     BY 孟超
header-img: img/S1xUm2jN2G.jpg
catalog: 	 true
tags:
    - Java
---

Javadoc命令

面向对象基础

一个public

# 1、类

### 1、类声明

```java
[public][abstract | final] class className [extends superclassName] [implements interfaceNameList] {
    //类体
}
```

所有的类都默认继承Object类。Object类为所有类的根类（继承Object类写不写都行，默认自己就是加上的）

```java 
//声明一个动物类
public class Animal extends Object {
    //类体
}
```



### 2、成员变量

```java
class className {
    [public | protected | private][static][final]type variableName;//成员变量
}
```

* public 、protected 、private是封装成员变量用的。
* static用于声明静态变量，也称为类变量
* final用于声明变量，该变量不能修改

### 3、成员方法

```java
class className {
    [public | protected | private][static][final | abstract ][native][synchronized]type methodName ([paramList]) [throws exceptionList]{
        //方法体
    }
}
```

* public 、protected 、private是封装用的。
* static用于声明静态方法，称为类方法
* final abstract 不能同时修饰方法，final修饰的方法不能在子类中覆盖。abstract用来修饰抽象方法，抽象方法必须在子类中实现。
* native修饰的方法称为本地方法，本地方法是调用平台本地代码，（如c、c++编写的代码），不能实现跨平台
* synchronized修饰的方法是同步的，当多线程方式同步方法时，只能串行的执行，保证线程是安全的。
* paramList是方法的参数列表，throws exceptionList是声明抛出异常列表。



# 2、包

### 1、包作用

Java中为了防止类、接口、枚举和注释等命名冲突引用了包（package）的概念。包本质上是命名空间。



## 2、包定义

Java中使用package语句定义包，**package语句应该放在源文件的第一行** 并且package语句适用于所有类型的文件，格式如下：

```java
package io.github.mengchaobbbigrui;

public class Date {

}
```

我个人博客网站的域名是mengchaobbbigrui.github.io,所以包名使用域名的倒置。如果域名中有数字作为了开头，则是非法的。需要更改，比如一个网站360.cn,域名倒置之后是cn.360。这就是不符合的，可以这样写a360.cn。



如果没有定义包的话，会被放进一个无名的包，就是默认包中。

在eclipse等IDE中可以很方便的定义一个包。



## 3、包引入

为了能够使用一个包中的类型。我们需要明显的引入这个包。Java中使用import语句实现。import语句应该位于package语句之后，所有类定义之前。

除了java.lang 包之外，所有的包都需要import导入。因为java.lang包会被解释器自动导入

语法如下：

```java
import io.github.mengchaobbbigrui;

public class HelloWorld {
    public static void main (String[] args) {
       
        Date date = new Date();//调用构造器来创建新的对象
        System.out.println(date);
    }
}
```



## 4、常用包

* java.lang包：包含了java语言的核心类，如Object、Class、String、包装类和Math等
* java.io包：提供多种输入输出流类。InputStream、OutputStream
* java.net包：进行网络操作相关的类。URL、Socket、ServerSocket
* java.util包: 包含一些使用工具类和接口，如集合，日期，日历相关类和接口
* java.text包：提供文本处理、日期格式化、数字格式化等相关类
* java.awt和java.swing包：包含图形用户界面开发和一些基础类和接口，以及高级组件。



# 3、方法重载(overload)

方法名字相同，功能不同。

方法重载中，是因为有参数列表不同：参数个数不同或者参数类型不同。

返回值类型不同不能区分方法重载。

```java
class ClassName {
    void receive (int i) {
        
        System.out.println(i);
    }
    void receive (int i,int j) {
        
        //构成重载
        System.out.println(i);
        System.out.println(j);
    }
    void receive (double i, double j) {
        
        //构成重载
        System.out.println(i);
        System.out.println(j);
    }
}
```



# 4、封装性与访问控制

java中对类成员变量和方法的访问控制一共有四个等级：

| 控制等级       | 同一个类 | 同一个包 | 不同包的子类 | 不同包非子类 |
| -------------- | -------- | -------- | ------------ | ------------ |
| 私有private    | 可以访问 |          |              |              |
| 默认(无关键字) | 可以访问 | 可以访问 |              |              |
| 保护protected  | 可以访问 | 可以访问 | 可以访问     |              |
| 公有public     | 可以访问 | 可以访问 | 可以访问     | 可以访问     |



# 5、静态方法和静态变量

静态方法又叫做类方法，是属于类的。

静态变量又叫做类变量，是属于类的。这两个都不是属于对象的。在使用的时候最好也用类来引用而不是对象。虽然说对象引用也可以，但是这两个最终还是属于类的。

static修饰的成员就是静态变量。static修饰的方法就是静态方法。

静态方法可以访问静态变量和其他静态方法。但是不能访问非静态变量。

```java
public class People {
    static int age = 15;//不显式初始化默认为0,这是静态变量
    
    static void displayAge () { //这是静态方法
        System.out.println(age);
    }
    
    public static void main (String[] args) {
        //main
        displayAge();
    }
}
```



# 6、静态代码块

当我们的静态变量不是在声明的时候同时初始化的话，或者比如需要计算才能初始化，我们就可以使用静态代码块

静态代码块就是在普通代码块之前加了一个static



```java
public class People {
    static int age;//不显式初始化默认为0,这是静态变量
    
    static void displayAge () { //这是静态方法
        System.out.println(age);
    }
    
    public static void main (String[] args) {
        //main
        displayAge();
    }
    
    static {            //静态代码块
        age = 15;
    }
}
```



静态代码块和构造器，在我们后面要说的继承中的调用顺序要搞清楚。都是从父类的开始先调用的。比如我们上面的类中继承了Object类，如果Object类中也有静态代码块的话，那么会先调用Object类中的，构造器也是如此。



# 7、内存问题说明及变量的作用域

定义的类类似于一个模板，而对象才是一个一个的实例。

类中定义的static变量和方法都在内存中的堆中放着。其他的应该是在代码段。

对象也都是放在类中的。

调用的main和局部变量和形式参数变量都在栈中。

局部变量（除了形参）使用的时候必须要进行显式初始化，否则报错。

成员变量不显式初始化的时候会根据类型自动初始化为0或者null。

作用域：

形参作用域：整个方法

方法局部变量：从定义处开始到方法结束。

代码块局部变量：从定义处开始到代码块结束。

类变量：从类的准备阶段起就开始存在。知道系统完全销毁这个类。

实例变量：从类的实例创建起开始存在，直到系统回收这个类。



# 8、构造器与对象创建

构造器是类中的特殊方法。用来初始化类的实例变量。这就是构造器，在创建对象new之后自动调用。

java构造器特点（规则）：

- 构造器名与类名必须相同。
- 构造干法没有任何返回值，包括void
- 狗仔方法只能与new结合使用
- 构造器在类中如果没有显式的使用的话，默认会自动有一个无参构造器。一经实现，默认构造器不复存在

```java
public class People {
    int age;
    string name;
    double height;
    
    //构造器，参数与成员变量名不同
    public People (int _age, String _name) {
        age = _age;
        name = _name;
    }
    
    //构造器，参数与成员变量名相同
    public People (int age, String name) {
        this.age = age;
        this.name = name;
    }
    
    //实现了重载
    public People (int age , String name, double height ) {
        this(age , name);
        this.height = height;
    }
    
    //main
    public static void main (string[] args) {
        
        //创建对象
        People p = new People(20,"孟超");
        
    }
}


```

构造器也可以进行封装，使用那些public 、protected、private和默认的修饰，访问级别也是一样的。

上面中的this关键字，指向对象本身，一个类可以通过this来获得他自身对象变量。

this语句必须是第一条语句。



如果在子类中，有成员变量和父类相同，则会屏蔽掉父类中的成员变量。就是在调用的时候会调用的是子类的成员变量。此时如果想调用父类中成员变量，则需要使用super关键字，例如super.x；这样来使用。

super关键字中，如果子类中定义了那name变量,而父类中没有定义，那么使用super.name 那么调用的是子类中的name。

this关键字中，如果父类中定义了name变量，而子类中没有定义，那么使用this.name时调用的是父类中的name。



其实根本上super和this应该是一个东西，哈希值都是一样的，只不过是super可能实现了类型转化，转换成了父类而已。

如果子类中有方法和父类相同，和变量一样，也会屏蔽掉。









# 9、垃圾回收机制

垃圾回收只会回收堆内存中的对象。不回收任何物理资源。

程序不是精确的控制垃圾回收的运行，只是在合适的时候运行。

在垃圾回收机制回收任何对象之前都会调用他的finalize()方法，该方法可能是该对象重新复活。





# 10、继承

继承：比如我们之前实现了一个person类，后面又有需求需要写一个student类。这两个类只是student类比person类多了一个成员变量，这样重新写这个类就不划算，所以我们这里才会引出来继承。

继承使用的是extends关键字。java中值允许单继承，不可以多继承。但是java可以实现多个接口。

继承会继承父类的所有的东西。

```java
public class Person {
    int age;
    String name;
    
    
}

//继承
class Student extends Person {
    String school;
}
```

所有的类其实都是默认继承的Object类的。所以说Object类是根类、

```java
public class Person {
    int age;
    String name;
    
    //构造器
    public Person (int age,String name) {
        this.age = age;
        this.name = name;
    }
    
    //构造器重载
    public Person (String name ) {
        this.name = name;
        age = 18;
    }
    
}

//继承
class Student extends Person {
    String school;
    
    //构造器，编译正确
    public Student (int age,String name,String school) {
        super(age,name); //调用父类构造器
        this.school = "西安电子科技大学"；
    }
    
    //构造器重载,编译争取
    public Student (String name,String school) {
        super(name);
        this.school = "西安电子科技大学"；
    }
    
    //构造器重载，编译错误
    public Student (String name,String school) {
        this.school = "西安电子科技大学"；
    }
    
}
```

super是用来调用父类构造器的方法用的。

super语句必须放在子类构造器中的第一行。

上面写的子类中的第三个构造器编译错误原因是，如果我们没写super的话，会自动调用super();

然而我们在父类中并没有去实现这个空构造器，所以会发生错误。

解决办法：

- 在父类中添加默认的构造方法，子类就会隐式的调用父类默认的构造方法。
- 在子类中构造方法中添加super语句，显式调用父类的构造方法，super语句必须在子类构造器中的第一行。
- 在子类构造方法中添加this语句，显式调用当前对象的其他构造方法。this语句必须是第一条语句

# 11、多态

多态发生的三个必要条件：

- 继承：多态发生在子列和父类之间
- 覆盖：子列覆盖父类的方法
- 声明的变量类型时父类类型，但是实例则指向子类实例。

