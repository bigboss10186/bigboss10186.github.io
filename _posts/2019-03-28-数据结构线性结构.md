---
layout:     post
title:      数据结构线性结构
subtitle:   数据结构
date:       2019-03-28
author:     BY 孟超
header-img: img/post-bg-ios10.jpg
catalog: 	 true
tags:
    - 数据结构
---

## 一、线性表

下面是我自己实现的代码，编译器通过了，结果也是对的，但是没准也会有错误存在。

不知道为啥在本地写好的代码，传到网站上就会变了一些，使某些格式就不太好看

```c
#include <stdio.h> 

#include <stdlib.h>

#define Maxsize 10  

//建立线性表

//将城市的各个参数进行数据封装

typedef struct city
{
 int number;
 char name[10];
}element;

//数据结构

typedef struct sqlsit
{
 element data[Maxsize];
 int length;
}sqlist;

//函数声明

void sqlist_init(sqlist *&L,element a[],int j);
int display(sqlist *L);
void sqlist_insert(sqlist*&L,element b,int n);
void sqlist_free(sqlist*&L);

int main()
{
 sqlist *L;
 element a[5] ={0};
    
    //本应该写出来数组的具体内容，不知道为什么就传不上去，本地编译都可以通过。。。

 sqlist_init(L,a,4);
 display(L);
 element b={5,"chang chun"};
 sqlist_insert(L,b,2);
 display(L);
 sqlist_free(L);
 return 0;
}

//建立线性表的代码

void sqlist_init(sqlist *&L,element a[],int j)
{
 int i=0;
// L=(sqlist *)malloc(sizeof(element)+4);
    
L=(sqlist *)malloc(sizeof(sqlist));
 for(i=0;i<j;i++)
 {
     L->data[i]=a[i];
 }
 L->length=j;
}

//打印线性表内容

int display(sqlist*L)
{
 if(L->length==0)
     return -1;
 else
     for(int i=0;i<L->length;i++)
     {
         printf("%d  ",L->data[i].number);
         printf("%s\n",L->data[i].name);
     }
     return 0;
}

//向线性表中插入元素

void sqlist_insert(sqlist*&L,element b,int n)
    //n是插在第几个位置(从0开始)，b是要插入的元素
{
 int j=L->length;
 for(int i=0;i<L->length-n+1;i++,j--)
 {
     L->data[j]= L->data[j-1];
 }
 L->data[n]=b;
 L->length= L->length+1;

}

//释放空间

void sqlist_free(sqlist*&L)
{
 free(L);
}
```



## 二、单链表

```c++
#include <stdio.h>  

#include <stdlib.h>


//数据结构

typedef struct node
{
    int data;
    struct node *next;
}node;

void linklist_head_init(node *&L,int a[],int n);
void linklist_foot_init(node *&L,int a[],int n);
void linklist_destory(node *&L);
void linklist_display(node *&L);
int linklist_insert(node *&L,int i,int e);

int main()
{
    int a[10]={0,1,2,3,4,5,6,7,8,9};
    node *L;
    linklist_head_init(L,a,9);
    linklist_insert(L,2,12);
    //linklist_foot_init(L,a,10);
    linklist_display(L);
    linklist_destory(L);
    return 0;
}

//头插法建立单链表

void linklist_head_init(node *&L,int a[],int n)
{
    node *s;
    L=(node*)malloc(sizeof(node));//创建头结点
    L->next=NULL;
    for(int i=0;i<n;i++)
    {
        s=(node*)malloc(sizeof(node));
        s->data=a[i];
        s->next=L->next;
        L->next=s;
    }
}

//尾插法建立单链表

void linklist_foot_init(node *&L,int a[],int n)
{
    node *s,*r;                   //r为尾指针始终指向链表的末尾
    L=(node*)malloc(sizeof(node));//创建头结点
    L->next=NULL;
    r=L;
    for(int i=0;i<n;i++)
    {
        s=(node*)malloc(sizeof(node));
        s->data=a[i];
        r->next = s;
        r=s;
    }
    r->next =NULL;
}
//销毁单链表

void linklist_destory(node *&L)
{
    node *pre=L,*p=L->next;
    while(p!=NULL)
    {
        free(pre);
        pre=p;
        p=pre->next;
    }
    free(p);
}


//打印单链表中的内容

void linklist_display(node *&L)
{
    while(L->next!=NULL)
    {
        printf("%d\n",L->next->data);
        L=L->next;
    }
}

//插入元素,在单链表中找到第i-1个节点*p，若存在这样的节点，将e插在其后方

int linklist_insert(node *&L,int i,int e)
{
    int j=0;
    node *p=L,*s;
    while(j<i-1&&p!=NULL)
    {
        j++;
        p=p->next;
    }
    if(p==NULL)
    {
        return -1;
    }
    else
    {
        s=(node *)malloc(sizeof(node));
        s->data=e;
        s->next=p->next;
        p->next=s;
        return 0;
    }
}
```

## 三、栈

线性栈

```c++
#include <stdio.h>  

#include <stdlib.h>  

#define Maxsize 11  

//数据结构

typedef struct
{
    int data[Maxsize];
    int top;    //记录栈顶
}sqstack;


//函数声明

void sqstack_init(sqstack *&s);
void sqstack_create(sqstack *&s,int a[],int n);
void sqstack_distory(sqstack *&s);
int sqstack_push(sqstack *&s,int &e);
int sqstack_pop(sqstack *&s,int &e);
void sqstack_display(sqstack *&s);


int main()
{
    int e=11;
    sqstack *s;
    int a[10]={1,2,3,4,5,6,7,8,9,10};

    sqstack_create(s,a,10);
    sqstack_push(s,e);
    sqstack_display(s);
    sqstack_distory(s);
    return 0;
}

//初始化栈

void sqstack_init(sqstack *&s)
{
    s=(sqstack*)malloc(sizeof(sqstack));
    s->top=-1;  //空栈
}

//创建一个栈

void sqstack_create(sqstack *&s,int a[],int n)
{
    s=(sqstack*)malloc(sizeof(sqstack));
    for(int i=0;i<n;i++)
    {
        s->data[i]=a[i];
    }
    s->top=n-1;
}

//销毁栈

void sqstack_distory(sqstack *&s)
{
    free(s);
}

//进栈

int sqstack_push(sqstack *&s,int &e)
{
    if(s->top==Maxsize -1)  //栈上溢出
        return -1;
    s->top++;
    s->data[s->top]=e;
    return 0;
}

//出栈

int sqstack_pop(sqstack *&s,int &e)
{
    if(s->top==-1)
        return -1;
    e=s->data[s->top];
    s->top--;
    return 0;
}

//打印

void sqstack_display(sqstack *&s)
{
    int i=0;
    while(s->top!=-1)
    {
        printf("%d\n",s->data[i]);
        s->top--;
        i++;
    }

}

```

## 链栈

**链栈中栈顶就是与头结点挨着的那个节点。**

```c++
#include <stdio.h>  

#include <stdlib.h>  


typedef struct listack
{
    int data;
    struct listack *next;
}listack;

//初始化栈

void sqstack_init(listack *&s)
{
    s=(listack*)malloc(sizeof(listack));
}

//销毁栈

void listack_destory( listack*&L)
{
    listack *pre=L,*p=L->next;
    while(p!=NULL)
    {
        free(pre);
        pre=p;
        p=pre->next;
    }
    free(p);
}

//创建一个栈

void listack_create( listack*&s,int a[],int n)
{
    s=(listack*)malloc(sizeof(listack));
    s->next=NULL;           //很必要
	listack *p;
    for(int i=0;i<n;i++)
    {
        p=(listack*)malloc(sizeof(listack));
        p->data=a[i];
        p->next=s->next;
        s->next=p;
    }
}

//进栈

int listack_push(listack *&s,int &e)
{
    listack *p;
    p=(listack*)malloc(sizeof(listack));
    p->data=e;
    p->next=s->next;
    s->next= p;
    return 0;
}

//出栈

int listack_pop(listack *&s,int &e)
{
    e=s->next->data;
    s->next=s->next->next;
    return 0;
}

//打印

void listack_display(listack *&s)
{
    while(s->next!=NULL)
    {
        printf("%d\n",s->next->data);//这里是这句话，不然会把头结点都会打印出来
        s=s->next;
    }

}

int main()
{
    listack *s;
    int a[10]={1,2,3,4,5,6,7,8,9,10};
    int e=10;
    listack_create(s,a,9);
    listack_push(s,e);
    listack_display(s);
    listack_destory(s);
    printf("hello world\n");
    return 0;
}


```

## 四、队列

#### 顺序队列

```c
#include <stdio.h>

#include <stdlib.h>

#define Maxsize 10


//数据结构  顺序队列
typedef struct sqqueue
{
    int data[Maxsize];
    int first;
    int rear;
}sqqueue;

//初始化队列
void sqqueue_init(sqqueue *&s)
{
    s=(sqqueue *)malloc(sizeof(sqqueue));
    s->first=s->rear=-1;
}

//进队
int enqueue(sqqueue *&s,int &e)
{
    if(s->rear==Maxsize-1)
        return -1;
    s->rear++;
    s->data[s->rear]=e;
    return 0;
}

//出队
int dequeue(sqqueue *&s,int &e)
{
    if(s->first==s->rear)
        return -1;
    s->first++;
    e=s->data[s->first];
    return 0;
}

//销毁队列
void destory_sqqueue(sqqueue *&s)
{
    free(s);
}
int main()
{
    sqqueue *s;
    return 0;


}
```

#### 环形队列

```c
//队空条件： first=rear

//队满条件： （rear+1）%Maxsize=first

//进队e操作：rear=（rear+1）%Maxsize；将e放在rear处

//出队操作：first=（first+1）%Maxsize


#include <stdio.h>

#include <stdlib.h>

#define Maxsize 10


//数据结构  环形队列（其实和顺序队列是一样的）
typedef struct sqqueue
{
    int data[Maxsize];
    int first;
    int rear;
}sqqueue;

//初始化队列
void sqqueue_init(sqqueue *&s)
{
    s=(sqqueue *)malloc(sizeof(sqqueue));
    s->first=s->rear=0;
}

//进队
int enqueue(sqqueue *&s,int &e)
{
    if((s->rear+1)%Maxsize==s->first)
        return -1;
    s->rear=(s->rear+1)%Maxsize;
    s->data[s->rear]=e;
    return 0;
}

//出队
int dequeue(sqqueue *&s,int &e)
{
    if(s->first==s->rear)
        return -1;
    s->first=(s->first+1)%Maxsize;
    e=s->data[s->first];
    return 0;
}

//销毁队列
void destory_sqqueue(sqqueue *&s)
{
    free(s);
}
int main()
{
    sqqueue *s;

    return 0;
}

```

#### 链式队列

```c
#include <stdio.h>

#include <stdlib.h>

#define Maxsize 10


typedef int ElemType;
//数据结构  链式队列
typedef struct qnode //数据节点
{
    ElemType data;
    struct qnode *next;
} QNode;
typedef struct //链队节点
{
    QNode *front;
    QNode *rear;
} LiQueue;

//初始化队列
void InitQueue(LiQueue *&q)
{
    q=(LiQueue *)malloc(sizeof(LiQueue));
    q->front=q->rear=NULL;
}
//进队
void enQueue(LiQueue *&q,ElemType e)
{
    QNode *p;
    p=(QNode *)malloc(sizeof(QNode));
    p->data=e;
    p->next=NULL;
    if (q->rear==NULL)
        q->front=q->rear=p;
    else
    {
        q->rear->next=p;
        q->rear=p;
    }
}


//出队
bool deQueue(LiQueue *&q,ElemType &e)
{
    QNode *t;
    if (q->rear==NULL)
        return false;
    t=q->front;
    if (q->front==q->rear)
        q->front=q->rear=NULL;
    else
        q->front=q->front->next;
    e=t->data;
    free(t);
    return true;
}

//销毁队列
void DestroyQueue(LiQueue *&q)
{
    QNode *p=q->front,*r;
    if (p!=NULL)
    {
        r=p->next;
        while (r!=NULL)
        {
            free(p);
            p=r;
            r=p->next;
        }
    }
    free(p);
    free(q);
}
int main()
{
    return 0;
}

```

## 五、串

串的堆存储方式

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

int main()
{
    char * a1 = NULL;
    char * a2 = NULL;
    a1 = (char*)malloc(10 * sizeof(char));
    strcpy(a1, "data.bian");//将字符串"data.bian"复制给a1
    
    a2 = (char*)malloc(10 * sizeof(char));
    strcpy(a2, "cheng.net");
    int lengthA1 = strlen(a1);//a1串的长度
    
    int lengthA2 = strlen(a2);//a2串的长度
    
    //尝试将合并的串存储在 a1 中，如果 a1 空间不够，则用realloc动态申请
    
    if (lengthA1 < lengthA1 + lengthA2) {
        a1 = (char*)realloc(a1, (lengthA1 + lengthA2+1) * sizeof(char));
    }
    //合并两个串到 a1 中
    
    for (int i = lengthA1; i < lengthA1 + lengthA2; i++) {
        a1[i] = a2[i - lengthA1];
    }
    //串的末尾要添加 \0，避免出错
    
    a1[lengthA1 + lengthA2] = '\0';
    printf("%s", a1);
    //用完动态数组要立即释放
    
    free(a1);
    free(a2);
    return 0;
}
```

## BF朴素模式算法

```c
#include <stdio.h>
#include <string.h>
//串普通模式匹配算法的实现函数，其中 B是伪主串，A是伪子串

int mate(char * B,char *A){
    int i=0,j=0;
    while (i<strlen(B) && j<strlen(A)) {
        if (B[i]==A[j]) {
            i++;
            j++;
        }else{
            i=i-j+1;
            j=0;
        }
    }
    //跳出循环有两种可能，i=strlen(B)说明已经遍历完主串，匹配失败；j=strlen(A),说明子串遍历完成，在主串中成功匹配
    
    if (j==strlen(A)) {
        return i-strlen(A)+1;
    }
    //运行到此，为i==strlen(B)的情况
    
    return 0;
}
int main() {
    int number=mate("ababcabcacbab", "abcac");
    printf("%d",number);
    return 0;
}
```

## KMP算法

```c
int KmpSearch(char* s, char* p)
{
	int i = 0;
	int j = 0;
	int sLen = strlen(s);
	int pLen = strlen(p);
	while (i < sLen && j < pLen)
	{
		//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++   
        
		if (j == -1 || s[i] == p[j])
		{
			i++;
			j++;
		}
		else
		{
			//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
			//next[j]即为j所对应的next值      
            
			j = next[j];
		}
	}
	if (j == pLen)
		return i - j;
	else
		return -1;

}
```

