---
layout:     post
title:      shell脚本
subtitle:   shell
date:       2019-04-02
author:     BY 孟超
header-img: img/post-bg-unix-linux.jpg
catalog: 	 true
tags:
    - shell
---

# shell script

## 一、shell脚本的创建、显示等

### 执行脚本

shell脚本的文件后缀名一般是.sh。一般我们在shell脚本中的第一行这样写**#！/bin/bash**,我们在执行脚本文件的时候，可以用多种方法，可以用路径，假设我们就在脚本的当前路径，可以用**./xxx.sh**来执行，还可以用完整路径来执行，我们还可以指定shell来执行，比如**bash xxx.sh** 或者**sh xxx.sh** 来执行。

以上这些种执行方法都会产生子shell来执行脚本，但是下面的这个命令，**source xxx.sh**会直接调用当前的shell来执行脚本。子shell来执行会浪费时间和一些额外的消耗，而且子shell不能使用父shell中的定义的局部变量。

### echo

在shell中我们一般用echo来打印，就像C语言中的printf一样。echo在shell中用于打印，比如在中断中输入如下命令

echo “hello world”

echo hello world

echo 'hello world'

这三个都会打印出来hello world，但其实他们还是有一点差别的。

先说说这个单引号的吧，这个单引号的很简单，不管里边是什么，就按照原模原样打印出来，不管里边是否有转义字符还是有没有变量，就是单引号里边是什么，就照样打印出来。既不会解释转义字符，也不会解释变量。

再来看有双引号的和什么都没有的，这两个当里边有转义字符或者变量的时候会自动解释的，我在网上看见的什么echo后面加一个-E就不会解释转义字符了，但是我在cent os7以及Ubuntu14.04上测试，不管什么样都会自动解释转义字符的。

但是没有单引号和双引号的也就是什么都没有的这种情况中是不能打印出分号；，因为分号有特殊作用。

echo hello; hello
对于上面的命令， Bash将echo hello作为一个命令，将hello作为另外一个命令。 

上面的命令和下面的形式是一样的。

echo hello

hello

相当于在终端输入了两个命令。

再说一说这个感叹号的事。在echo中使用这个！感叹号的时候，如echo “hello ！world”，echo hello！world会报错，因为感叹号在这里代表的是历史命令。加转义字符的符号\的时候，会将这个转移字符一并打印出来

但是在没有引号的情况下，末尾用感叹号是可以打印出来的，有双引号的时候末尾用双引号也是不行滴。据说在脚本文件中使用也没有毛病（待鉴定），在终端中使用就有问题。

### 变量

linux中有环境变量和局部变量之分，可以用env或者printenv来打印系统环境变量，用set命令来打印当前shell下的所有变量。

### 重定向输入和输出

**输出重定向**

```shell
 date > test6
```

比如这个命令，就会将之前的打印到屏幕上的东西打印到这个文件里，如果没有这个文件，则会创建这个 文件，如果有这个文件，则会清除之前文件里边的所有东西。

```shell
 date >> test6
```

这个命令会将打印出来的信息追加到这个文件末尾，原来的内容还存在。

**输入重定向**

```shell
wc < test6
```

wc命令可以对对数据中的文本进行计数 ,输出行数，词数，字节数，这是将文件重定向给wc命令。

### 管道

将一个命令的输出作为另一个命令的输入。 

```shell
ls -l | less
```

我可以将ls命令输出的东西，都传给less这个命令，以方便观察。输出的太多，就会发现这个好处了

### 数学运算

利用bc命令来实现。bc命令默认是不会保留小数点的，需要在每次使用的时候自己进行设置。要退出bash计算器，你必须输入quit。 

scale变量的默认值是0 ，scale就是用来确定保留几位小数的。

```shell
#!/bin/bash

var1=$(echo "scale=4; 3.44 / 5" | bc)

echo The answer is $var1
```

可以这样写来实现计算。

## 二、if相关语法

if语句与then可以搭配elif进行相关的命令。

```shell
#!/bin/bash   
# Testing nested ifs - use elif    
#    
testuser=NoSuchUser    

if grep $testuser /etc/passwd     
then    
echo "The user $testuser exists on this system "     
#    
elif ls -d /home/$testuser  
then  
	echo "The user $testuser does not exist on this system."  
	echo "However, $testuser has a directory."  
```

if命令后边可以跟双方括号[[   ]],可以实现一些特殊的东西，比如两个*****号代表幂运算

还有case命令

```shell 
#!/bin/bash  
# using the case command  
#  
case $USER in  
rich | barbara)  
echo "Welcome, $USER"  
echo "Please enjoy your visit";;  
testing)  
echo "Special testing account";;  
jessica)  
echo "Do not forget to log off when you're done";;  
*)  
echo "Sorry, you are not allowed here";;  
esac  

```

## 三、for循环

for命令最基本的用法就是遍历for命令自身所定义的一系列值。

```shell
#!/bin/bash  

for test in Alabama Alaska Arizona Arkansas California Colorado  
do  
echo The next state is $test  
done  
$ ./test1  
The next state is Alabama  
The next state is Alaska  
The next state is Arizona  
The next state is Arkansas  
The next state is California  
The next state is Colorado  
```



每次for命令遍历值列表，它都会将列表中的下个值赋给$test变量。 $test变量可以像for命令语句中的其他脚本变量一样使用。在最后一次迭代后， $test变量的值会在shell脚本的剩余部分一直保持有效。它会一直保持最后一次迭代的值（除非你修改了它）。 

**C语言中for循环**

```shell
for (i = 0; i < 10; i++)
{
	printf("The next number is %d\n", i);
}
```

C语言模式的for循环也可以在shell脚本中使用。很棒



**读取变量列表**

```shell
#!/bin/bash   
# using a variable to hold the list  
list="Alabama Alaska Arizona Arkansas Colorado"  
list=$list" Connecticut"  
for state in $list  
do  
echo "Have you ever visited $state?"  
done  
```



**用通配符读取目录**

```shell
#!/bin/bash
# iterate through all the files in a directory
for file in /home/rich/test/*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done
```

**循环处理文件数据**

```shell
#!/bin/bash  
# changing the IFS value  
IFS.OLD=$IFS  
IFS=$'\n'  
for entry in $(cat /etc/passwd)  
do  
echo "Values in $entry –"  
IFS=:  
for value in $entry  
do  
echo " $value"  
done  
done
```



## 四、while命令

```shell 
#while命令的格式是： 
while test command  
do  
other commands   
done  
```

## 五、until命令

until命令和while命令工作的方式完全相反。 until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0， bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了 。

## 六、循环处理文件数据

修改IFS环境变量 （IFS环境变量： IFS 是一种 set 变量，当 shell 处理"命令替换"和"参数替换"时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。）



典型的例子是处理/etc/passwd文件中的数据。这要求你逐行遍历/etc/passwd文件，并将IFS变量的值改成冒号，这样就能分隔开每行中的各个数据段了。 

```shell
#!/bin/bash 
# changing the IFS value  
IFS.OLD=$IFS    #保存之前的IFS，可以过后复原
IFS=$'\n'  
for entry in $(cat /etc/passwd)  
do  
echo "Values in $entry –"  
IFS=:  
for value in $entry  
do 
echo " $value" 
done  
done  
```



## 七、控制循环

break

continue

## 八、处理循环输出

最后，在shell脚本中，你可以对循环的输出使用管道或进行重定向。这可以通过在done命令之后添加一个处理命令来实现。 



```shell
for file in /home/rich/*  
do  
if [ -d "$file" ]  
then  
echo "$file is a directory"  
elif  
echo "$file is a file"  
fi  
done > output.txt  
```

















$^

$@

$0

$?

$#

$*

