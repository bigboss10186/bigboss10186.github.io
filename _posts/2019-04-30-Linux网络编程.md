---
layout:     post
title:      linux网络编程
subtitle:   linux API
date:       2019-04-30
author:     BY 孟超
header-img: img/post-bg-swift.jpg
catalog: 	 true
tags:
    - linux API
---

# Linux网络编程

### 1、基础知识

**网络通信的层次**

(1)硬件部分：网卡

(2)操作系统底层：网卡驱动

(3)操作系统API：socket接口

(4)应用层：低级（直接基于socket接口编程）

(5)应用层：高级（基于网络通信应用框架库）

(6)应用层：更高级（http、网络控件等）

**网络通信基础知识**

三大网络

(1)电信网、电视网络、互3联网（三网合一）

网络通信的传输媒介

(1)无线传输：WIFI、蓝牙、zigbee、4G/5G/GPRS等

(2)有线通信：双绞线、同轴电缆、光纤等

OSI 7层网络模型（记住）

![EGymVO.png](https://s2.ax1x.com/2019/04/30/EGymVO.png)

TCP/IP对应的网络模型

[![EGsRgI.md.png](https://s2.ax1x.com/2019/04/30/EGsRgI.md.png)](https://imgchr.com/i/EGsRgI)

网卡

(1)计算机上网必备硬件设备，CPU靠网卡来连接外部网络

(2)串转并设备

(3)数据帧封包和拆包

(4)网络数据缓存和速率适配

集线器（HUB）

(1)信号中继放大，相当于中继器

(2)组成局域网络，用广播方式工作。

(3)注意集线器是不能用来连接外网的

交换机

(1)包含集线器功能，但更高级

(2)交换机中有地址表，数据包查表后直达目的通信口而不是广播

(3)找不到目的口时广播并学习


路由器

(1)路由器是局域网和外部网络通信的出入口

(2)路由器将整个internet划分成一个个的局域网，却又互相联通。

(3)路由器对内管理子网（局域网），可以在路由器中设置子网的网段，设置有线端口的IP地址，设置dhcp功能等，因此局域网的IP地址是路由器决定的。

(4)路由器对外实现联网，联网方式取决于外部网络（如ADSL拨号上网、宽带帐号、局域网等）。这时候路由器又相当于是更高层级网络的其中一个节点而已。

(5)所以路由器相当于有2个网卡，一个对内做网关、一个对外做节点。

(6)路由器的主要功能是为经过路由器的每个数据包寻找一条最佳路径（路由）并转发出去。其实就是局域网内电脑要发到外网的数据包，和外网回复给局域网内电脑的数据包。

(7)路由器技术是网络中最重要技术，决定了网络的稳定性和速度。

DNS（Domain Name Service 域名服务）

(1)网络世界的门牌号：IP地址

(2)IP地址的缺点：难记、不直观

(3)IP地址的替代品：域名，譬如https://mengchaobbbigrui.github.io

(4)DNS服务器就是专门提供域名和IP地址之间的转换的服务的，因此域名要购买的

(5)我们访问一个网站的流程是：先使用IP地址（譬如谷歌的DNS服务器IP地址为8.8.8.8）访问DNS服务器（DNS服务器不能是域名，只能是直接的IP地址），查询我们要访问的域名的IP地址，然后再使用该IP地址访问我们真正要访问的网站。这个过程被浏览器封装屏蔽，其中使用的就是DNS协议。

(6)浏览器需要DNS服务，而QQ这样的客户端却不需要（因为QQ软件编程时已经知道了腾讯的服务器的IP地址，因此可以直接IP方式访问服务器）


DHCP（dynamic host configuration protocl，动态主机配置协议）

(1)每台计算机都需要一个IP地址，且局域网内各电脑IP地址不能重复，否则会地址冲突。

(2)计算机的IP地址可以静态设定，也可以动态分配

(3)动态分配是局域网内的DHCP服务器来协调的，很多设备都能提供DHCP功能，譬如路由器。

(4)动态分配的优势：方便接入和断开、有限的IP地址得到充分利用

NAT（network address translation，网络地址转换协议）

(1)IP地址分为公网IP（internet范围内唯一的IP地址）和私网IP（内网IP），局域网内的电脑使用的都是私网IP（常用的就是192.168.1.xx）

(2)网络通信的数据包中包含有目的地址的IP地址

(3)当局域网中的主机要发送数据包给外网时，路由器要负责将数据包头中的局域网主机的内网IP替换为当前局域网的对外外网IP。这个过程就叫NAT。

(4)NAT的作用是缓解IPv4的IP地址不够用问题，但只是类似于打补丁的形式，最终的解决方案还是要靠IPv6。

(5)NAT穿透


IP地址分类（IPv4）

(1)IP地址实际是一个32位二进制构成，在网络通信数据包中就是32位二进制，而在人机交互中使用点分十进制方式显示。

(2)IP地址中32位实际包含2部分，分别为：网络地址和主机地址。子网掩码，用来说明网络地址和主机地址各自占多少位。

(3)由网络地址和主机地址分别占多少位的不同，将IP地址分为5类，最常用的有3类

三类IP地址

(1)A类

(2)B类

(3)C类

(4)127.0.0.0用来做回环测试loopback

如何判断2个IP地址是否在同一子网内

(1)网络标识 = IP地址 & 子网掩码

(2)2个IP地址的网络标识一样，那么就处于同一网络。



源IP地址：发出数据包的网络的IP地址

目标IP地址：要接收数据包的计算机的IP地址

二进制方式			0xffffffff			0xC0A80166/0x6601A8C0		本质

点分十进制方式		255.255.255.255		192.168.1.102				方便人看的

IP地址 = 网络地址 + 主机地址

网络地址用来表示子网

主机地址是用来表示子网中的具体某一台主机的。



譬如可以8位表示网络，24位表示主机

也可以16位表示网络，16位表示主机

14为表示网络，18位表示主机



子网掩码为255.255.255.0时表示前24位为网络地址，后8位为主机地址

子网掩码为255.255.0.0时表示前16位为网络地址，后16位为主机地址

网络地址决定了这种网络中一定可以有多少个网络，譬如子网掩码为255.255.255.0时表示我们这一种网络一共最多可以有2^24个，每个这种网络中可以有2^8个主机。

如果子网掩码为255.255.0.0时，表示我们这种网络可以有2^16个网络，每个这种网络中最多可以有2^16个主机。

192.168.1.102 & 255.255.255.0 = 192.168.1.0

192.168.1.253 & 255.255.255.0 = 192.168.1.0

192.168.1.4和192.168.12.5，如果子网掩码是255.255.255.0那么不在同一网段，如果子网掩码是255.255.0.0那么就在同一个网段

### 2、TCP/IP网络编程

**TCP/IP协议引入**

(1)TCP/IP协议是用的最多的网络协议实现

(2)TCP/IP，对应OSI的7层

(3)我们编程时最关注应用层，了解传输层，网际互联层和网络接入层不用管

**BS和CS**

(1)CS架构介绍（client server，客户端服务器架构）

(2)BS架构介绍（broswer server，浏览器服务器架构）

**关于TCP理解的重点**

(1)TCP协议工作在传输层，对上服务socket接口，对下调用IP层

(2)TCP协议面向连接，通信前必须先3次握手建立连接关系后才能开始通信。

(3)TCP协议提供可靠传输，不怕丢包、乱序等。

**TCP如何保证可靠传输**

(1)TCP在传输有效信息前要求通信双方必须先握手，建立连接才能通信

(2)TCP的接收方收到数据包后会ack给发送方，若发送方未收到ack会丢包重传

(3)TCP的有效数据内容会附带校验，以防止内容在传递过程中损坏

(4)TCP会根据网络带宽来自动调节适配速率（滑动窗口技术）

(5)发送方会给各分割报文编号，接收方会校验编号，一旦顺序错误即会重传。



**TCP的三次握手**

(1)建立连接需要三次握手与TCP的四次握手

![EGydiQ.png](https://s2.ax1x.com/2019/04/30/EGydiQ.png)



(2)建立连接的条件：服务器listen时客户端主动发起connect

服务器或者客户端都可以主动发起关闭

**注：这些握手协议已经封装在TCP协议内部，socket编程接口平时不用管**

**基于TCP通信的服务模式**

(1)具有公网IP地址的服务器（或者使用动态IP地址映射技术）

(2)服务器端socket、bind、listen后处于监听状态

(3)客户端socket后，直接connect去发起连接。

(4)服务器收到并同意客户端接入后会建立TCP连接，然后双方开始收发数据，收发时是双向的，而且双方均可发起

(5)双方均可发起关闭连接

**常见的使用了TCP协议的网络应用**

(1)http、ftp

(2)QQ服务器

(3)mail服务器



**socket编程接口介绍**

**建立连接**

(1)socket。socket函数类似于open，用来打开一个网络连接，如果成功则返回一个网络文件描述符（int类型），之后我们操作这个网络连接都通过这个网络文件描述符。

(2)bind

(3)listen

(4)connect

**发送和接收**

(1)send和write

(2)recv和read

**辅助性函数**

下面中的函数用于转化IP地址的方式用的，由十六进制转化成点分十进制等。最好用（2）中的函数，因为可以支持IPV6，而（1）只支持IPV4

(1)inet_aton、inet_addr、inet_ntoa

(2)inet_ntop、inet_pton

表示IP地址相关数据结构

(1)都定义在 /usr/include/netinet/in.h

(2)struct sockaddr，这个结构体是网络编程接口中用来表示一个IP地址的，注意这个IP地址是不区分IPv4和IPv6的（或者说是兼容IPv4和IPv6的）



(3)typedef uint32_t in_addr_t;		网络内部用来表示IP地址的类型



(4)

```c
struct in_addr
{
    in_addr_t s_addr;
};
```



(5)

```c
struct sockaddr_in
  {
    __SOCKADDR_COMMON (sin_);
    in_port_t sin_port;                 /* Port number.  */
    
    struct in_addr sin_addr;            /* Internet address.  */
    

	/* Pad to size of `struct sockaddr'.  */
    
	unsigned char sin_zero[sizeof (struct sockaddr) -
                       __SOCKADDR_COMMON_SIZE -
                       sizeof (in_port_t) -
                       sizeof (struct in_addr)];

  };
```



(6)struct sockaddr			

这个结构体是linux的网络编程接口中用来表示IP地址的标准结构体，bind、connect等函数中都需要这个结构体，

这个结构体是兼容IPV4和IPV6的。在实际编程中这个结构体会被一个struct sockaddr_in或者一个struct sockaddr_in6所填充。



IP地址转化函数实践

```c
#include <stdio.h>

#include <sys/socket.h>

#include <netinet/in.h>

#include <arpa/inet.h>


#define IPADDR	"192.168.1.102"

// 0x66		01	a8		c0

// 102		1	168		192

// 网络字节序，其实就是大端模式


int main(void)
{
	struct in_addr addr = {0};
	char buf[50] = {0};
	
	addr.s_addr = 0x6703a8c0;
	
	inet_ntop(AF_INET, &addr, buf, sizeof(buf));

	printf("ip addr = %s.\n", buf);
	
	
/*	
	// 使用inet_pton来转换
	int ret = 0;
	struct in_addr addr = {0};
	
	ret = inet_pton(AF_INET, IPADDR, &addr);
	if (ret != 1)
	{
		printf("inet_pton error\n");
		return -1;
	}
	
	printf("addr = 0x%x.\n", addr.s_addr);
*/	
	
	/*
	in_addr_t addr = 0;
	
	addr = inet_addr(IPADDR);
	
	printf("addr = 0x%x.\n", addr);		// 0x6601a8c0
*/	
	return 0;
}



```



**soekct实践编程**

服务器端程序编写

(1)socket

(2)bind

(3)listen

(4)accept，返回值是一个fd，accept正确返回就表示我们已经和前来连接我的客户端之间建立了一个TCP连接了，以后我们就要通过这个连接来和客户端进行读写操作，读写操作就需要一个fd，这个fd就由accept来返回了。

注意：socket返回的fd叫做监听fd，是用来监听客户端的，不能用来和任何客户端进行读写；accept返回的fd叫做连接fd，用来和连接那端的客户端程序进行读写。

概念：端口号，实质就是一个数字编号，用来在我们一台主机中（主机的操作系统中）唯一的标识一个能上网的进程。端口号和IP地址一起会被打包到当前进程发出或者接收到的每一个数据包中。每一个数据包将来在网络上传递的时候，内部都包含了发送方和接收方的信息（就是IP地址和端口号），所以IP地址和端口号这两个往往是打包在一起不分家的。

```c
#include <stdio.h>

#include <sys/socket.h>

#include <sys/types.h>          /* See NOTES */

#include <sys/socket.h>

#include <arpa/inet.h>

#include <string.h>



#define SERPORT		9003
#define SERADDR		"192.168.1.141"		// ifconfig看到的

#define BACKLOG		100


char recvbuf[100];


int main(void)
{
	// 第1步：先socket打开文件描述符
    
	int sockfd = -1, ret = -1, clifd = -1;
	socklen_t len = 0;
	struct sockaddr_in seraddr = {0};
	struct sockaddr_in cliaddr = {0};
	
	char ipbuf[30] = {0};
	
	
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (-1 == sockfd)
	{
		perror("socket");
		return -1;
	}
	printf("socketfd = %d.\n", sockfd);
	
	// 第2步：bind绑定sockefd和当前电脑的ip地址&端口号
    
	seraddr.sin_family = AF_INET;		// 设置地址族为IPv4
    
	seraddr.sin_port = htons(SERPORT);	// 设置地址的端口号信息
    
	seraddr.sin_addr.s_addr = inet_addr(SERADDR);	//　设置IP地址
    
	ret = bind(sockfd, (const struct sockaddr *)&seraddr, sizeof(seraddr));
	if (ret < 0)
	{
		perror("bind");
		return -1;
	}
	printf("bind success.\n");
	
	// 第三步：listen监听端口
    
	ret = listen(sockfd, BACKLOG);		// 阻塞等待客户端来连接服务器
    
	if (ret < 0)
	{
		perror("listen");
		return -1;
	}
	
	// 第四步：accept阻塞等待客户端接入
    
	clifd = accept(sockfd, (struct sockaddr *)&cliaddr, &len);
	printf("连接已经建立，client fd = %d.\n", clifd);
	
/*	

	// 建立连接之后就可以通信了
	
	// 客户端给服务器发
	
	ret = recv(clifd, recvbuf, sizeof(recvbuf), 0);
	
	printf("成功接收了%d个字节\n", ret);
	
	printf("client发送过来的内容是：%s\n", recvbuf);
	
*/

    
/*
	// 客户端反复给服务器发
	
	while (1)
	
	{
	
		ret = recv(clifd, recvbuf, sizeof(recvbuf), 0);
		
		//printf("成功接收了%d个字节\n", ret);
		
		printf("client发送过来的内容是：%s\n", recvbuf);	
		
		memset(recvbuf, 0, sizeof(recvbuf));
		
	}
	
*/
    
	// 服务器给客户端发
    
	strcpy(recvbuf, "hello world.");
	ret = send(clifd, recvbuf, strlen(recvbuf), 0);
	printf("发送了%d个字符\n", ret);

	
	return 0;
}



```



客户端程序编写

(1)socket

(2)connect

```c
#include <stdio.h>

#include <sys/socket.h>

#include <sys/types.h>          /* See NOTES */

#include <sys/socket.h>

#include <arpa/inet.h>

#include <string.h>


#define SERADDR		"192.168.1.141"		// 服务器开放给我们的IP地址和端口号

#define SERPORT		9003


char sendbuf[100];



int main(void)
{
	// 第1步：先socket打开文件描述符
    
	int sockfd = -1, ret = -1;
	struct sockaddr_in seraddr = {0};
	struct sockaddr_in cliaddr = {0};
	
	// 第1步：socket
    
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (-1 == sockfd)
	{
		perror("socket");
		return -1;
	}
	printf("socketfd = %d.\n", sockfd);
	
	// 第2步：connect链接服务器
    
	seraddr.sin_family = AF_INET;		// 设置地址族为IPv4
    
	seraddr.sin_port = htons(SERPORT);	// 设置地址的端口号信息
    
	seraddr.sin_addr.s_addr = inet_addr(SERADDR);	//　设置IP地址
    
	ret = connect(sockfd, (const struct sockaddr *)&seraddr, sizeof(seraddr));
	if (ret < 0)
	{
		perror("listen");
		return -1;
	}
	printf("成功建立连接\n");

/*	

	// 建立连接之后就可以开始通信了
	
	
	
	strcpy(sendbuf, "hello world.");
	
	
	ret = send(sockfd, sendbuf, strlen(sendbuf), 0);
	
	
	printf("发送了%d个字符\n", ret);
	
	
*/
    
/*

	while (1)
	
	
	{
	
		printf("请输入要发送的内容\n");
		
		scanf("%s", sendbuf);
		
		//printf("刚才输入的是：%s\n", sendbuf);
		
		ret = send(sockfd, sendbuf, strlen(sendbuf), 0);
		
		printf("发送了%d个字符\n", ret);
		
	}
	
*/
    
	ret = recv(sockfd, sendbuf, sizeof(sendbuf), 0);
	printf("成功接收了%d个字节\n", ret);
	printf("client发送过来的内容是：%s\n", sendbuf);
	
	
	return 0;
}



```



