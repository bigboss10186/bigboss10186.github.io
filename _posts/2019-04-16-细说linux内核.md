---
layout:     post
title:      细说linux内核
subtitle:   linux
date:       2019-04-16
author:     BY 孟超
header-img: img/SyxnyrgH3M.jpg
catalog: 	 true
tags:
    - linux内核

---



Linux内核官方网址www.kernel.org

# 1、Linux内核细说



**操作系统及核心功能**

在一本《Linux命令行与shell脚本编程》中有详细讲解

操作系统的主要作用就是管理计算机硬件，给应用程序提供一个运行环境。

(1)内存管理。如果没有操作系统，内存是需要程序自己来管理的。譬如在uboot中要使用内存的哪里是自己随便用的，没有注册也没有限制。这时候如果程序自己不小心把同一块内存重复用了就会出现程序逻辑错误。系统大了之后（内存多了）内存管理非常麻烦；有了操作系统之后，操作系统负责管控所有的内存，所有的应用程序需要使用内存时都要向操作系统去申请和注册，由操作系统的内存管理模块来分配内存给你使用，这样好处是可以保证内存使用不会冲突。

(2)进程调度。操作系统下支持多个应用程序同时运行（所以可以一边聊QQ一边看电影···），这是宏观上的并行。实际上在单核心CPU上微观上是不能并行的，宏观上的并行就是操作系统提供的分时复用机制。操作系统的进程调度模块负责在各个进程之间进行切换。

(3)硬件设备管理。没有操作系统时要控制任何硬件都要自己写代码，有了操作系统后操作系统本身会去控制各个硬件，应用程序就不用考虑硬件的具体细节了。操作系统的硬件设备管理模块就是驱动模块。
(4)文件系统。文件系统是管理存储设备的一种方式。存储设备是由很多个扇区组成的，每个扇区有512/1024/2048/4096字节，存储设备要以扇区为单位进行读写。如果没有文件系统，程序要自己去读写扇区，就得记得哪个文件在哪个扇区。有了文件系统之后我们人不用再关注扇区，人只用关注文件系统中的目录和文件名，而不用管这个文件在物理磁盘的哪个扇区。

**操作系统扩展功能**

(1)协议栈

(2)有用的应用程序包。应用程序本身不属于操作系统内核的一部分，应用程序是给人用的，面向某种功能的。譬如ping程序用来测试网络是否联通，ifconfig程序用来配置网卡。

**内核和驱动的关联**

驱动属于内核的一部分

(1)驱动就是内核中的硬件设备管理模块

(2)驱动工作在内核态。

(3)驱动程序故障可能导致整个内核崩溃

(4)驱动程序漏洞会使内核不安全

内核和应用程序、根文件系统的关联

**应用和内核的关系**

(1)应用程序不属于内核，而是在内核之上的

(2)应用程序工作在用户态，是受限制的。

(3)应用程序故障不会导致内核崩溃

(4)应用程序通过内核定义的API接口来调用内核工作

(5)总结1：应用程序是最终目标

(6)总结2：内核就是为应用程序提供底层资源管理的服务员

**内核和根文件系统**

(1)根文件系统提供根目录。

(2)进程1存放在根文件系统中

(3)内核启动最后会去装载根文件系统。

(4)总结：根文件系统为操作系统启动提供了很多必备的资源：根目录、进程1



**linux内核的模块化设计**

**什么是模块化设计**

(1)因为linux内核很庞大，代码量很大、东西很多，如果设计时完全设计成一体（各个文件、各个函数之间紧耦合），复杂度超出了人所能理解的范围。所以模块化设计也是一种必要。

(2)模块化设计就是内核中各个功能模块在代码上是彼此独立的，譬如说调度系统和内存管理系统之间并没有全局变量的互相引用，甚至函数互相调用也很少，就算有也是遵循一个接口规范的。模块化设计的目的就是实现功能模块的松耦合。

**模块化设计的体现**

(1)配置时可裁剪。linux内核在编译之前可以进行配置，配置时可以选择将组成内核的成千上万个模块每一个要或者不要。要了之后还有更多的一些细节的配置。

(2)模块化编译和安装。为了操作方便，逐渐从静态的升级变成了动态的升级（不需要重启系统，更不需要重新烧录系统）。这种动态的升级也是由模块化来支持的。

(3)源码中使用条件编译。这种在uboot中已经见过了。

**模块化设计的好处**

(1)功能可裁剪、灵活性

(2)可扩展性（动态安装卸载、新硬件支持）

(3)利于协作

模块化设计是一种普遍性的系统设计原则

选择合适版本的内核

**linux内核版本变迁简史**

(1)linux0.01。初版

(2)linux0.11。很多讲linux内核源代码解析的书都是以这个版本为原本来讲。《图解linux内核设计的艺术》

(3)linux2.4。比较接近现代的版本，很多经典的书都是以2.4版本内核为参照的，譬如《LDD3》。linux2.4的晚期内核在前几年还会经常碰到有用的。

(4)linux2.6早期。2.6的早期和2.4晚期内核挺像的。

(5)linux2.6晚期。2.6的晚期内核较早期内核有一些改变，尤其是驱动相关的部分和一些头文件的位置。2.6的晚期内核目前还算是比较主流。

(6)linux3.x 4.x

现在已经有Linux5.0版本了。



# 2、Linux内核的编译和配置



**linux内核源码目录结构**

(1)Kbuild，Kbuild是kernel build的意思，就是内核编译的意思。这个文件就是linux内核特有的内核编译体系需要用到的文件。

(2)Makefile，这个是linux内核的总makefile，整个内核工程用这个Makefile来管理的。

(3)mk，是九鼎在移植时自己添加的，不是linux内核本身的东西。九鼎添加这个文件的作用是用这个文件来整天管理kernel目录的配置和编译，也就是说这个文件有点类似于我们之前移植uboot时自己创建的那个cp.sh。

Kbuild、Kconfig等文件，都是和内核的配置体系有关的。

(1)arch。arch是architecture的缩写，意思是架构。arch目录下是好多个不同架构的CPU的子目录，譬如arm这种cpu的所有文件都在arch/arm目录下，X86的CPU的所有文件都在arch/x86目录下。

(2)block。英文是块的意思，在linux中block表示块设备（以块（多个字节组成的整体，类似于扇区）为单位来整体访问），譬如说SD卡、iNand、Nand、硬盘等都是块设备。你几乎可以认为块设备就是存储设备。block目录下放的是一些linux存储体系中关于块设备管理的代码。

(3)crypto。英文意思是加密。这个目录下放了一些各种常见的加密算法的C语言代码实现。譬如crc32、md5、sha1等。

(4)Documentation。里面放了一些文档。

(5)drivers。驱动目录，里面分门别类的列出了linux内核支持的所有硬件设备的驱动源代码。

(6)firmware。固件。什么是固件？固件其实是软件，不过这个软件是固话到IC里面运行的叫固件。就像S5PV210里的iROM代码。

(7)fs。fs就是file system，文件系统，里面列出了linux支持的各种文件系统的实现。

(8)include。头文件目录，公共的（各种CPU架构共用的）头文件都在这里。每种CPU架构特有的一些头文件在arch/arm/include目录及其子目录下。

(9)init。init是初始化的意思，这个目录下的代码就是linux内核启动时初始化内核的代码。

(10)ipc。ipc就是inter process commuication，进程间通信，里面都是linux支持的IPC的代码实现。

(11)kernel。kernel就是内核，就是linux内核，所以这个文件夹下放的就是内核本身需要的一些代码文件。

(12)lib。lib是库的意思，这里面都是一些公用的有用的库函数，注意这里的库函数和C语言的库函数不一样的。在内核编程中是不能用C语言标准库函数，这里的lib目录下的库函数就是用来替代那些标准库函数的。譬如在内核中要把字符串转成数字用atoi，但是内核编程中只能用lib目录下的atoi函数，不能用标准C语言库中的atoi。譬如在内核中要打印信息时不能用printf，而要用printk，这个printk就是我们这个lib目录下的。

(13)mm。mm是memory management，内存管理，linux的内存管理代码都在这里。

(14)net。该目录下是网络相关的代码，譬如TCP/IP协议栈等都在这里。

(15)scripts。脚本，这个目录下全部是脚本文件，这些脚本文件不是linux内核工作时使用的，而是用来辅助对linux内核进行配置编译生产的。我们并不会详细进入分析这个目录下的脚本，而是通过外围来重点学会配置和编译linux内核即可。

(16)security。安全相关的代码。不用去管。

(17)sound。音频处理相关的。

(18)tools。linux中用到的一些有用工具

(19)usr。目录下是initramfs相关的，和linux内核的启动有关，暂时不用去管。

(20)virt。内核虚拟机相关的，暂时不用管。

总结：这么多目录跟我们关系很紧密的就是arch和drivers目录，然后其他有点相关的还有include、block、mm、net、lib等目录。

**内核配置和编译体验**

先确认Makefile

(1)主要是检查交叉编译工具链有没有设置对。CROSS_COMPILE   ?= /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-

(2)确认ARCH = arm。主要目的是为了编译时能找到arch/arm目录。

**make x210ii_qt_defconfig**

(1)最后只要出现：configuration written to .config这句话，就证明我们的操作是正确的。如果没有出现这句话，就有错误。

注意：如果这一步配置没有得到.config文件，是不能进行到下一步的。实际测试时没有.config也可以make menuconfig，但是这样做出来的内核编译和烧写运行应该是有问题的。

**make menuconfig**

(1)可能出现的错误1：ncurses库没装

错误信息：

 Unable to find the ncurses libraries or the

 required header files.

 make menuconfig' requires the ncurses libraries.

 Install ncurses (ncurses-devel) and try again.

解决方案：  apt-get install libncurses5-dev 

(2)可能出现的错误2：屏幕太小

错误信息：

Your display is too small to run Menuconfig!

It must be at least 19 lines by 80 columns.

解决方案：全屏，或者是把字体调小。

总结：make menuconfig是第二步配置，具体的用法和配置意义在后面课程讲。我们这里因为是九鼎已经移植过的，所以第二步配置是可以不做的，直接退出即可。用键盘的向右方向键移动到EXIT，按回车退出。

**make**

(1)可能出现的错误1：莫名其妙的错误，可以试试先make distclean

(2)代码本身的错误：具体问题具体分析

(3)编译完成后得到的内核镜像不在源码树的根目录下，在arch/arm/boot这个目录下。得到的镜像名是zImage



**配置的关键是得到.config文件**

(1).config以.开头，是一个隐藏文件，因此平时是看不到的，需要ls -a来看

(2)当我们make distclean后（也就是说默认情况下）是没有.config文件的，我们配置的两步过程就是为了得到内容合适的.config文件

(3).config文件是linux内核在编译过程中很重要的一个文件，其作用类似与uboot中的

include/configs/x210_sd.h，内核在编译过程中会读取.config中的配置项，并且用这些配置项去指导整个编译链接过程。

(4).config文件的格式类似于脚本文件，其中内容为类似于于：CONFIG_ARM=y的一个一个的配置项。这些配置项就类似于脚本文件中定义的一个一个变量，所以这一行可以被理解为定义了一个变量CONFIG_ARM，这个变量的值为y。

(5).config文件中每一行都是一个配置项，从.config文件的规模可以看出linux内核的可配置项有两三千个。所以linux内核是高度可配置的，而且linux内核的所有配置项很难全部搞明白。因为linux内核的配置项太多太繁杂超出了人的大脑能够记忆和处理的数量级，因此linux内核不像uboot那样直接手工配置，而是发明了一个图形化的配置工具menuconfig。

**make xx_defconfig和make menuconfig相配合**

(1)我们为了对.config文件中的两三千个配置项做逐一合适的配置，专门发明了两步结合的配置方式。

(2)其实只要人的记忆足够好，大脑足够厉害，完全可以手工去书写/修改.config文件完成内核配置，最终只要.config中内容是正确的，就不影响编译过程。

(3)第一步：make xxx_defconfig解决的问题是大部分的配置项（这一步结束后99%的配置项就已经正确了），下来就是对个别不同的针对我们的开发板进行细节调整，细节调整就通过make menuconfig来完成。

(4)make xxx_defconfig这一步其实是参考别人已经做好的，这样做有很多好处：减少很多工作量，避开了很多自己不懂的配置项（譬如对内存管理的、调度系统的等模块的配置项），我们只用管自己需要管的。

(5)make menuconfig其实就是读取第一步得到的.config，然后给我们一个图形化的界面，让我们可以更加容易的找到自己想要修改的配置项，然后更改配置他。

**make xx_defconfig到底做了什么？**

(1)make x210ii_qt_defconfig其实相当于：cp arch/arm/configs/x210ii_qt_defconfig .config

(2)arch/arm/configs目录下的这么多个xxx_defconfig哪里来的？其实这些文件都是别人手工配置好适合一定的开发板的.config文件后自己把.config文件保存过去的。譬如说我们用S5PV210这个SoC，针对这个SoC的开发板的最初配置肯定是三星的工程师去做的。

**menuconfig的使用和演示**

使用说明解释

(1)make ，menuconfig中本身自带的提示就有所有的用法，这里只要全部理解就可以了。

(2)menuconfig中间的选择区中有很多个选择项，每个选择项对应.config文件中的一个配置项，每一个选择项都可以被选择和配置操作，选择区中的每一项都是有子目录的，将光标放在选择项上按Enter键可以进入子目录（子目录可能还会有子目录）。选择区太短放不下所有的一个目录层级的选项，可以用箭头按键的向上箭头和向下箭头来上翻和下翻。

注：在menuconfig中操作相关的几个键盘按键，主要是；Enter、ESC、四个方向箭头按键。还有一些特殊字符按键，如/  ? 

向上和向下箭头，主要用来在选择项菜单中目录浏览时上下翻

回车，主要作用是选中并且执行select/exit/help。

ESC，主要作用是返回上一层

向左和向右箭头，主要作用是在菜单选项（select、exit、help）间切换。

(3)用法翻译：

箭头按键导航整个菜单，回车按键选择子菜单（注意选项后面有 --->的选项才是有子菜单的，没有这个标识的没有子菜单），高亮的字母是热键（快捷键），键盘按键Y、N、M三个按键的作用分别是将选中模块编入、去除、模块化。双击ESC表示退出，按下？按键可以显示帮助信息，按下/按键可以输入搜索内容来全局搜索信息（类似于vi中的搜索），[]不可以模块化，<>的才可以模块化。

注：linux内核中一个功能模块有三种编译方法：一种是编入、一种去去除、一种是模块化。所谓编入就是将这个模块的代码直接编译连接到zImage中去，去除就是将这个模块不编译链接到zImage中，模块化是将这个模块仍然编译，但是不会将其链接到zImage中，会将这个模块单独链接成一个内核模块.ko文件，将来linux系统内核启动起来后可以动态的加载或卸载这个模块。

在menuconfig中选项前面的括号里，*表示编入，空白表示去除，M表示模块化



**menuconfig的工作原理**

menuconfig本身由一套软件支持

(1)linux为了实现图形化界面的配置，专门提供了一套配置工具menuconfig。

(2)ncurses库是linux中用来实现文字式的图形界面，linux内核中使用了ncurses库来提供menuconfig

(3)scripts\kconfig\lxdialog目录下的一些c文件就是用来提供menuconfig的那些程序源代码。

menuconfig读取Kconfig文件

(1)menuconfig本身的软件只负责提供menuconfig工作的这一套逻辑（譬如在menuconfig中通过上下左右箭头按键来调整光标，Enter ESC键等按键按下的响应），而并不负责提供内容（菜单里的项目）。

(2)menuconfig显示的菜单内容（一方面是菜单的目录结构，另一方面是每一个菜单项目的细节）是由内核源码树各个目录下的Kconfig文件来支持的。Kconfig文件中按照一定的格式包含了一个又一个的配置项，每一个配置项在make menuconfig中都会成为一个菜单项目。而且menuconfig中显示的菜单目录结构和源码目录中的Kconfig的目录结构是一样的。

(3)在相应的Kconfig文件中删除一个config项，则再次make menuconfig时这个项目已经看不到了。

menuconfig读取/写入.config文件

(1)刚才已经知道menuconfig的菜单内容来自于Kconfig文件，但是每一个菜单的选择结果（Y、N、M）却不是保存在Kconfig文件中的。Kconfig文件是不变的，Kconfig文件只是决定有没有这个菜单项，并不管这个菜单项的选择结果。

(2)menuconfig工作时在我们make menuconfig打开时，他会读取.config文件，并且用.config文件中的配置选择结果来初始化menuconfig中各个菜单项的选择值。

总结：菜单项的项目内容从Kconfig文件来，菜单项的选择值从.config文件来

(3)当我们每次退出make menuconfig时，menuconfig机制会首先检查我们有没有更改某些配置项的值，如果我们本次没有更改过任意一个配置项目的值那直接退出；如果我们有改动配置项的值则会提示我们是否保存。此时如果点保存，则会将我们更改过的配置重新写入.config文件中记录，下一次再次打开make menuconfig时会再次加载.config，最终去编译内核时编译连接程序会考虑.config中的配置值指导整个编译连接过程。

总结：本节课主要内容就是讲：menuconfig和Kconfig和.config的关系。

**Kconfig文件详解**

**Kconfig的格式**

(1)Kconfig按照一定的格式来书写，menuconfig程序可以识别这种格式，然后从中提取出有效信息组成menuconfig中的菜单项。

(2)将来在做驱动移植等工作时，有时需要自己添加Kconfig中的一个配置项来将某个设备驱动添加到内核的配置项目中，这时候就需要对Kconfig的配置项格式有所了解，否则就不会添加。

(3)#开头的行是注释行

(4)menuconfig表示菜单（本身属于一个菜单中的项目，但是他又有子菜单项目）、config表示菜单中的一个配置项（本身并没有子菜单下的项目）。

(5)menuconfig或者config后面空格隔开的大写字母表示的类似于 NETDEVICES 的就是这个配置项的配置项名字，这个字符串前面添加CONFIG_后就构成了.config中的配置项名字。

(6)一个menuconfig后面跟着的所有config项就是这个menuconfig的子菜单。这就是Kconfig中表示的目录关系。

(7)内核源码目录树中每一个Kconfig都会source引入其所有子目录下的Kconfig，从而保证了所有的Kconfig项目都被包含进menuconfig中。这个也告诉我们：如果你自己在linux内核中添加了一个文件夹，一定要在这个文件夹下创建一个Kconfig文件，然后在这个文件夹的上一层目录的Kconfig中source引入这个文件夹下的Kconfig文件。

**tristate和bool的含义**

(1)tristate意思是三态（3种状态，对应Y、N、M三种选择方式），bool是要么真要么假（对应Y和N）。所以tristate的意思就是这个配置项可以被三种选择，bool的意思是这个配置项只能被2种选择。

**depends的含义**

(1)depends中文意思是“取决于”或者“依赖于”，所以depends在这里的意思是：本配置项依赖于另一个配置项。如果那个依赖的配置项为Y或者M，则本配置项才有意义；如果依赖的哪个配置项本身被设置为N，则本配置项根本没有意义。

(2)depends项目会导致make menuconfig的时候找不到一些配置项。所以你在menuconfig中如果找不到一个选项，但是这个选项在Kconfig中却是有的，则可能的原因就是这个配置项依赖的一个配置项是不成立的。

(3)depends并不要求依赖的配置项一定是一个，可以是多个，而且还可以有逻辑运算。这种时候只要依赖项目运算式子的裸机结果为真则依赖就成立。

**help**

(1)帮助信息，告诉我们这个配置项的含义，以及如何去配置他。

Kconfig和.config文件和Makefile三者的关联

(1)配置项被配置成Y、N、M会影响.config文件中的CONFIG_XXX变量的配置值。

(2)这个.config中的配置值（=y、=m、没有）会影响最终的编译链接过程。如果=y则会被编入（built-in），如果=m会被单独连接成一个ko模块，如果没有则对应的代码不会被编译。那么这么是怎么实现的？都是通过makefile实现的。

(3)obj-$(CONFIG_DM9000) += dm9000.o

如果CONFIG_DM9000变量值为y，则obj += dm9000.o，因此dm9000.c会被编译；如果CONFIG_DM9000变量未定义，则dm9000.c不会被编译。如果CONFIG_DM9000变量的值为m则会被连接成ko模块（这个是在linux内核的Makefile中定义的规则）

总结：把menuconfig中的菜单项、Kconfig中的配置项、.config中的一行、 Makefile中的一行，这4个东西结合起来理解，则整个linux内核的配置体系就明了了。
