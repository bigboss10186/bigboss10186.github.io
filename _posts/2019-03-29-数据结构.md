---
layout:     post
title:      数据结构非线性结构
subtitle:   数据结构
date:       2019-03-29
author:     BY 孟超
header-img: img/post-bg-ios10.jpg
catalog: 	 true
tags:
    - 数据结构
---

## 一、树的概念及常用术语

### ①树的概念

树是一种非线性结构，树是n个节点的有限集合，且满足：

（1)如果n＝0，则称为空树，否则，有且仅有一个特定的节点被称为根。

（2）当n>1的时候，其余节点被分成m个互不相交的子集，每个子集又是一颗树，并且称为根的子树。

### ②树的常用术语

（1）节点：包含一个数据元素及若干指向其子树根的分支；

（2）节点的度：节点拥有的子树个数；

（3）叶子（终端节点）：度为0的节点（其实就是最末尾的那一个）

（4）非终端节点：度不为0 的节点

（5）节点的层次：树中根节点的层次为1，根节点子树的层次为2 ，以此类推

（6）树的度：树中所有的节点的度的最大值

（7）树的深度：树中节点层次的最大值

（8）孩子：节点子树的根称为这个节点的孩子；

（9）双亲：节点的直接上层节点称为该节点的双亲；

（10）兄弟：同一双亲的孩子互称为兄弟

（11）堂兄弟：双亲在同一层次上的节点互称为堂兄弟

（12）路径：从某个节点到其子树中另一个节点之间的分支，构成两个节点之间的路径

（13）子孙：以某个节点为根的子树中的所有节点都被称为该节点的子孙；

（14）祖先：从根节点到该节点路径上的所有节点

（15）森林：m(m>=0)颗互不相交的树的集合

（16）有序树和无序树：如果树中每棵子树从左向右的排列拥有一定的顺序，不得互换，则称为有序树，否则称为无序树，在有序树中，最左边的子树的根称为第一个孩子，最右边的子树的根称为最后一个孩子。

## 二、二叉树

二叉树是树的另一种树形结构，他与树的区别是：每个节点最多有两棵子树；子树有左右之分。

#### 二叉树的性质：

性质①：在二叉树的第i层上最多有2^(i-1)个节点（i>=1).

性质②：深度为k的二叉树最多有2^(k-1)个节点。

性质③：对任意一个二叉树，如果其终端节点个数为n,度为2 的节点个数为m，则n=m+1.

#### 满二叉树和完全二叉树

满二叉树：一个深度为k且有2^(k-1)个节点的二叉树称为满二叉树。

完全二叉树：如果对一颗深度为k的二叉树节点按照编号规则进行编号，所得顺序与满二叉树相应节点的编号顺序一致，则称这棵树是完全二叉树。

满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树。，但是完全二叉树的前（k-1）层一定是满二叉树。在完全二叉树中如果一个节点没有做孩子，则他一定没有右孩子。完全二叉树可以在最后一个层次上没有最后几个叶子节点。

#### 二叉树的存储结构及创建

##### ①顺序存储结构

通过增加虚节点，将二叉树转化为完全二叉树。然后进行编号存储。（可能会造成内存浪费）

#### ②链式存储结构

二叉树的节点至少包括三个域：数据域，左孩子指针域，右孩子指针域。如果为了方便查找还可以增加一个双亲指针域。

```c
typedef struct node
{
    int data;					//数据域     
    
    struct node *lchild,*rchild;//左指针域和右指针域    
    
}BTNode;
```

```c
 
//按前序输入二叉树中节点的值
//#表示空树，构造二叉链表表示二叉树T
void CreateBiTree(BTNode * T)
{
    int ch;
    scanf("%c",ch);
    if(ch == '#')
    {
        *T = NULL;
    }
    else
    {
        *T=(BTNode)malloc(sizeof(BTNode));
        if(!*T)
            exit(OVERFLOW);
        (*T)-> data =ch;//生成根节点
        CreateBiTree(&(*T)->lchild);//构造左子树
        CreateBiTree(&(*T)->rchild);//构造右子树
    }
}
 
```

#### 查找节点FindNode(*b,x)

找到值为x的结点后返回节点指针，否则返回NULL

用递归算法，采用”根-左子树-右子树”的顺序，查找值为x的节点。

```c
BTNode *FindNode(BTNode *b,ElemType x)  
{      
    BTNode *p;   
    if (b==NULL)      
        return NULL;   
    else if (b->data==x)         
        return b;    
    else     
    {         
        p=FindNode(b->lchild,x);    
        if (p!=NULL)	  
            return p;   
        else return FindNode(b->rchild,x);  
    }  
}  
```



这里使用的是递归，仔细分析即可。

#### 求高度BTNodeDepth(*b)

二叉树的高度的递归模型f()

```c
int BTNodeDepth(BTNode *b)
{    
    int lchilddep,rchilddep;
    if (b==NULL)return(0); //空树的高度为0     
    else
        
    {
        lchilddep=BTNodeDepth(b->lchild); //求左子树的高度         
        rchilddep=BTNodeDepth(b->rchild); //求右子树的高度         
        return (lchilddep>rchilddep)? (lchilddep+1):(rchilddep+1));
        
    }
}
```





#### 二叉树的遍历递归算法

三种遍历

先序遍历：根节点–>左子树–>右子树。

中序遍历：左子树–>根节点–>右子树。

后序遍历：左子树–>右子树–>根节点.

先序遍历算法

```c
void PreOrder(BTNode *b)
{
	if (b!=NULL)
	{
		printf("%c ",b->data);
		PreOrder(b->lchild);
		PreOrder(b->rchild);
	}
}
```

中序遍历算法

```c
void InOrder(BTNode *b)
{
	if (b!=NULL)
	{
		InOrder(b->lchild);
		printf("%c ",b->data);
		InOrder(b->rchild);
	}
}
```

后序遍历算法

```c
void PostOrder(BTNode *b)
{
	if (b!=NULL)
	{
		PostOrder(b->lchild);
		PostOrder(b->rchild);
		printf("%c ",b->data);
	}
}
```

我在大话数据结构这本书中明白了，这几种方式遍历的顺序。下面说一下：