---
layout:     post
title:      数据结构非线性结构
subtitle:   数据结构
date:       2019-03-29
author:     BY 孟超
header-img: img/post-bg-ios10.jpg
catalog: 	 true
tags:
    - 数据结构
---

## 一、树的概念及常用术语

### ①树的概念

树是一种非线性结构，树是n个节点的有限集合，且满足：

（1)如果n＝0，则称为空树，否则，有且仅有一个特定的节点被称为根。

（2）当n>1的时候，其余节点被分成m个互不相交的子集，每个子集又是一颗树，并且称为根的子树。

### ②树的常用术语

（1）节点：包含一个数据元素及若干指向其子树根的分支；

（2）节点的度：节点拥有的子树个数；

（3）叶子（终端节点）：度为0的节点（其实就是最末尾的那一个）

（4）非终端节点：度不为0 的节点

（5）节点的层次：树中根节点的层次为1，根节点子树的层次为2 ，以此类推

（6）树的度：树中所有的节点的度的最大值

（7）树的深度：树中节点层次的最大值

（8）孩子：节点子树的根称为这个节点的孩子；

（9）双亲：节点的直接上层节点称为该节点的双亲；

（10）兄弟：同一双亲的孩子互称为兄弟

（11）堂兄弟：双亲在同一层次上的节点互称为堂兄弟

（12）路径：从某个节点到其子树中另一个节点之间的分支，构成两个节点之间的路径

（13）子孙：以某个节点为根的子树中的所有节点都被称为该节点的子孙；

（14）祖先：从根节点到该节点路径上的所有节点

（15）森林：m(m>=0)颗互不相交的树的集合

（16）有序树和无序树：如果树中每棵子树从左向右的排列拥有一定的顺序，不得互换，则称为有序树，否则称为无序树，在有序树中，最左边的子树的根称为第一个孩子，最右边的子树的根称为最后一个孩子。

## 二、二叉树

二叉树是树的另一种树形结构，他与树的区别是：每个节点最多有两棵子树；子树有左右之分。

#### 二叉树的性质：

性质①：在二叉树的第i层上最多有2^(i-1)个节点（i>=1).

性质②：深度为k的二叉树最多有2^(k-1)个节点。

性质③：对任意一个二叉树，如果其终端节点个数为n,度为2 的节点个数为m，则n=m+1.

#### 满二叉树和完全二叉树

满二叉树：一个深度为k且有2^(k-1)个节点的二叉树称为满二叉树。

完全二叉树：如果对一颗深度为k的二叉树节点按照编号规则进行编号，所得顺序与满二叉树相应节点的编号顺序一致，则称这棵树是完全二叉树。

满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树。，但是完全二叉树的前（k-1）层一定是满二叉树。在完全二叉树中如果一个节点没有做孩子，则他一定没有右孩子。完全二叉树可以在最后一个层次上没有最后几个叶子节点。

#### 二叉树的存储结构

##### ①顺序存储结构

通过增加虚节点，将二叉树转化为完全二叉树。然后进行编号存储。（可能会造成内存浪费）

#### ②链式存储结构

二叉树的节点至少包括三个域：数据域，左孩子指针域，右孩子指针域。如果为了方便查找还可以增加一个双亲指针域。

```c
typedef struct node
{
    int data;					//数据域
    
    struct node *lchild,*rchild;//左指针域和右指针域
    
}BTNode;
```

 例：str —— A ( B ( D ( , G ) ) , C ( E , F ) )
 扫描采用括号表示法表示二叉树的字符串，读到的符号为ch
 使用一个栈St保存双亲节点，k指定其后处理的节点是双亲节点（保存在栈中）的左孩子节点（k=1）还是右孩子节点（k=2）。
 分以下几种情况：
① 若ch='('：则将前面刚创建的节点作为双亲节点进栈，并置k=1，表示其后创建的节点将作为这个节点的左孩子节点；
② 若ch=‘,’：表示其后创建的节点为右孩子节点，置k=2；
③ 若ch=')'：表示栈中节点的左右孩子节点处理完毕，退栈；
④ 其他情况：
当k=1时，表示这个节点作为栈中节点的左孩子节点；
当k=2时，表示这个节点作为栈中节点的右孩子节点。
 如此循环直到str处理完毕。

```c
void CreateBTNode(BTNode * &b,char *str)  
{      
    BTNode *St[MaxSize],*p=NULL;     
    int top=-1,k,j=0;     
    char ch;     
    b=NULL;    
    ch=str[j];      
    while (ch!='\0')     
    {           
        switch(ch)      
        {      
            case '(':  
                top++;   
                St[top]=p;   
                k=1;        
                break;     
            case ')':  
                top--;       
                break;   
            case ',':  
                k=2;      
                break;    
            default:      
                p=(BTNode *)malloc(sizeof(BTNode));   
                p->data=ch;       
                p->lchild=p->rchild=NULL;     
                if (b==NULL) //p为二叉树的根  
                    
                    b=p;	
                
                else //p要作为已建立的二叉树的子树   
                    
                {   
                    
                    switch(k)  
                    {   
                        case 1:  
                            St[top]->lchild=p;  
                            break;   
                        case 2:   
                            St[top]->rchild=p;  
                            break;  
                    }  
                }  
        }   
        j++;  
        ch=str[j];  
    }  
}  

```

#### 查找节点FindNode(*b,x)

 找到值为x的结点后返回节点指针，否则返回NULL

 用递归算法，采用"根-左子树-右子树"的顺序，查找值为x的节点。

```c
BTNode *FindNode(BTNode *b,ElemType x)  
{      
    BTNode *p;   
    if (b==NULL)      
        return NULL;   
    else if (b->data==x)         
        return b;    
    else     
    {         
        p=FindNode(b->lchild,x);    
        if (p!=NULL)	  
            return p;   
        else return FindNode(b->rchild,x);  
    }  
}  
```





#### 求高度BTNodeDepth(*b)

二叉树的高度的递归模型f()

```c
int BTNodeDepth(BTNode *b)
{    
    int lchilddep,rchilddep;
    if (b==NULL)return(0); //空树的高度为0
    else
    {
        lchilddep=BTNodeDepth(b->lchild); //求左子树的高度
        
        rchilddep=BTNodeDepth(b->rchild); //求右子树的高度
        
        return (lchilddep>rchilddep)? (lchilddep+1):(rchilddep+1));
        
    }
}
```



### 输出二叉树DispBTNode(*b)	

```c
void DispBTNode(BTNode *b)
{   
    if (b!=NULL) 
    {  
        printf("%c",b->data);
        if (b->lchild!=NULL || b->rchild!=NULL)
        { 
            printf("(");
            DispBTNode(b->lchild);
            if (b->rchild!=NULL) printf(",");
            DispBTNode(b->rchild);
            printf(")"); 
        }
    }
}


 
```

#### 二叉树的遍历

三种遍历

先序遍历：根节点-->左子树-->右子树。

中序遍历：左子树-->根节点-->右子树。

后序遍历：左子树-->右子树-->根节点.