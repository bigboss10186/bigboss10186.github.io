---
layout:     post
title:      arm的基本常识
subtitle:   arm
date:       2019-04-07
author:     BY 孟超
header-img: img/arm.jpg
catalog: 	 true
tags:
    - arm
---

# 1、ARM公司发展史

①ARM前身为艾康电脑，于1978年在英国剑桥成立。

②1980年苹果与艾康合作，研究ARM。

③1985年研究出ARM1（全球第一款商用RISC架构CPU）。

④1990年从艾康电脑中分离出Advanced RICS Machines（ARM），ARM公司正式成立。

# 2、ARM公司的商业模式

ARM公司不生产芯片，他们只设计芯片，出售版权

# 3、ARM的各种版本号



| 内核版本号 | SOC版本号            | 芯片型号                                    |
| ---------- | -------------------- | ------------------------------------------- |
| ARMv4      | ARM7                 | s3c44B0                                     |
|            | ARM9                 | s3c2440 s3c2410                             |
| ARMv5      | ARM9+xscale          |                                             |
| ARMv6      | ARM11                | s3c6410                                     |
|            | cortex-M(单片机)     | STM32                                       |
| ARMv7      | cortex-A(嵌入式)     | cortex-A8（s5pv210）cortex-A9（exynos4412） |
|            | cortex-R(工业实时性) |                                             |



# 4、SOC与CPU的区别

SOC=system on chip(片上系统)

ARM出售的内核就是CPU，SOC中包含外设，集成度高



# 5、交叉编译

何为交叉编译：A机编写程序源代码，编译后得到可执行城西，发布给B机运行。

就像我们是在linux下编译程序，烧录到s5pv210，这就是交叉编译。

交叉编译的特点：必须使用专用的交叉编译工具链（arm-linux-gcc），不能本地调试，通过JTAG等下载工具下载程序到目标嵌入式开发板中，才可以。



# 6、嵌入式系统特点

① 专用，软硬件可裁剪

②低功耗、高可靠性和高稳定性

③代码可固化

④实时性

⑤软件代码短小精悍

⑥专业开发人员

⑦专业开发工具及开发环境

⑧弱交互性



# 7、可编程器件的原理

①CPU在固定的时钟频路控制下进行有节奏的运行

②CPU通过总线读取外部的可存储设备中的二进制指令集然后解码执行

③所谓的指令集是CPU设计的时候，也就是ARM设计的时候已经确定下来了。

④我们平时的数字电路里边的芯片只有一对门电路，是不可编程器件



# 8、RISC 和CISC架构

Intel采用的就是CISC架构的CPU，可以用最少的指令完成任务，编译器也比较好设计，但是工艺相当复杂，功耗高，比较难做。

ARM采用的就是RISC架构，功耗低，芯片好做，精简指令集，指令少



# 9、统一编址、独立编址、哈佛结构、冯诺依曼结构

IO：input output 如uart  LCD LED等外设都是IO，内存，CPU通过地址总线来访问，

统一编址：内存和IO都是通过总线地址来让CPU访问。

独立编址：IO用专用的指令集去访问特定的外设。



哈佛结构：程序和数据分开放，程序放在ROM中，数据放在RAM中。（单片机都是这样的）

冯诺依曼结构：数据和程序都放在内存中。



# 10、寄存器

寄存器有两种，一种是特殊功能寄存器，一种是通用寄存器



# 11、内存与外存的各种物质

内存（RAM）：

SRAM:上电即可运行，不需要初始化。

SDRAM：同步动态随机存储器。需要初始化才可以使用

DDR：双向倍速SDRAM。需要初始化才能使用。有DDR1、DDR2、DDR3、DDR4。



外存：

Norflash:上电就可以使用，是总线式访问的，接到SROM bank上。

Nandflash:分为MLC和SLC。MLC常用便宜但是不稳定，SLC贵，但是稳定，需要初始化才能用

eMMC：分为iNand（SanDisk）和movinand(三星设计)，需要初始化才能用

onenand:三星设计的一种存储物质，贼贵，需要初始化才能用

SD/TF/MMC卡：存储卡

ESSD：固态硬盘

SATA：机械硬盘



# 12、s5pv210介绍

我用的是s5pv210的芯片，s5pv210有内置的64KB的IROM（类似于norflash,可以上电直接使用。）和96KB的IRAM（是SRAM可以上电直接使用的）。

其中的IROM是由内置代码的，固话在上面，由三星公司烧进去的，未公开的代码。IROM中有各种外存的设备初始化的代码，因为世界上应该也就只有这几种物质，但是没有DDR初始化的代码，因为生产DDR的生产商很多。

**s5pv210**的启动方式详解

①三星推荐的启动方式：

三星公司要求所使用的BootLoader必须大于16KB，又必须小于96KB，我们先假设我们的BootLoader为80KB，开机，首先BL0（也就是IROM上的代码）最开始运行，BL0会根据判断我们的启动方式，选择外部的存储介质。，加载BootLoader中的前16KB到SRAM中运行，这个前16KB的代码就是BL1。BL1运行会加载BL2（剩余的64KB的代码）到SARM中运行。BL2会将DDR初始化。并将内核加载到DDR中去运行，BootLoader结束。



②uboot的启动方式：

uboot可以任意大小，无所谓。首先BL0（也就是IROM上的代码）最开始运行，BL0会根据判断我们的启动方式，选择外部的存储介质。，加载BootLoader中的前8KB或者16KB到SRAM中运行，这个前16KB的代码就是BL1。这个BL1就会去初始化DDR。并且把整个uboot加载到DDR中去执行，BL2就会去启动内核。

实际在uboot中，会有一个脚本将uboot截成一个8KB或者16KB大小的文件，这就是BL1 ，放在SD卡中的第一个扇区。整个uboot作为BL2放在第49个扇区。（放在哪个扇区都是自己设计的，放在哪里就去哪里找），执行完BL1之后，BL1会重定位将BL2加载到DDR，然后长跳转执行后面的程序。



# 13、ARM的编程模式和7种工作模式

编程模式：

ARM模式：ARM指令集

thumb模式：thumb指令集

thumb2模式：thumb2指令集



工作模式：

user：非特权模式，大部分都在这种模式下工作



FIQ：快速中断模式					  异常模式，特权模式

IRQ：普通中断模式					  异常模式，特权模式

Supervisor：复位或者软中断模式		 异常模式，特权模式

Abort：存取异常					     异常模式，特权模式

undef:未定义模式					   异常模式，特权模式

 

system：系统模式					   特权模式



# 14、ARM的通用寄存器

user模式下可用的寄存器是r0~r15和cpsr寄存器，其中r13又叫sp（栈）寄存器，r14又叫lr寄存器。r15又叫pc寄存器。

pc（程序控制寄存器）中的地址是哪里，CPU就执行在哪里。

FIQ：其中的寄存器r0~r7和r15以及cpsr寄存器和user一样，但是有自己的r8~r14,以及spsr

IRQ：其中的寄存器r0~r12和r15以及cpsr寄存器和user一样，但是有自己的r13~r14,以及spsr

Supervisor：其中的寄存器r0~r12和r15以及cpsr寄存器和user一样，但是有自己的r13~r14,以及spsr

Abort：其中的寄存器r0~r12和r15以及cpsr寄存器和user一样，但是有自己的r13~r14,以及spsr

undef：其中的寄存器r0~r12和r15以及cpsr寄存器和user一样，但是有自己的r13~r14,以及spsr



system：和user的寄存器一模一样，但是这是特权模式下的。



这里所有的cpsr又叫程序状态寄存器，其中bit0~bit4位工作模位，bit5是ARM编程模式位，bit6和bit7是FIQ和IRQ的中断使能位，bit28~bit31是条件位。



# 15、ARM异常处理方式

异常向量表

![异常向量表](https://i.loli.net/2019/04/07/5ca9f4b573828.png)



发生异常时：

①拷贝cpsr到spsr中

②设置cpsr

③保存返回地址到lr

④设置pc到异常处

⑤返回：从spsr到cpsr，从lr到pc



# 16、ARM汇编

①两个概念：指令与伪指令

•（汇编）指令是CPU机器指令的助记符，经过编译后会得到一串10组成的机器码，可以由CPU读取执行。

•（汇编）伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码。

②两种不同风格的ARM指令

•ARM官方的ARM汇编风格：指令一般用大写、Windows中IDE开发环境（如ADS、MDK等）常用。如： LDR R0, [R1]

•GNU风格的ARM汇编：指令一般用小写字母、linux中常用。如：ldr r0, [r1]

我们常用GNU风格的ARM汇编。因为我们经常在linux下进行开发。

**ARM汇编特点1：LDR/STR架构**

•ARM采用RISC架构，CPU本身不能直接读取内存，而需要先将内存中内容加载入CPU中通用寄存器中才能被CPU处理。

•ldr（load register）指令将内存内容加载入通用寄存器。

•str（store register）指令将寄存器内容存入内存空间中。

•ldr/str组合用来实现 ARM CPU和内存数据交换

**ARM汇编特点2：8种寻址方式**

•寄存器寻址  mov r1, r2                                                #把r2的值传到r1

•立即寻址  mov r0, #0xFF00                                         #把常数0xFF00

•寄存器移位寻址  mov r0, r1, lsl #3                             #r1中的书左移三位然后给r0寄存器

​              LSL：逻辑左移，移位后寄存器空出的低位补0；

​              LSR：逻辑右移，移位后寄存器空出的高位补0；

​              ASR：算数右移，移位过程中，符号位保存不变，如果源操作数为正数，则移位后空出的高位补 

​                         0，否则补1。

​              ROR：循环右移，移位后，移出的低位，填入移位空出的高位。

​               RRX：带扩展的循环右移，操作数右移一位，移位空出的高位，用C标志的值填充。

​                

•寄存器间接寻址  ldr r1, [r2]                                       #r2加上[]符号之后，代表r2中的书存放的是内存地 

​                                                                                        址，这句话就是将r2中的内存地址中的数给r1.

•基址变址寻址  ldr r1, [r2, #4]                                     #这句话就是将r2中的内存地址加4中的数给r1.

•多寄存器寻址  ldmia r1!, {r2-r7, r12}                        #ldm是数据加载指令，指令的后缀ia表示，每次

​                                                                                         执行完成加载操作后，r1寄存器的值自增1个字。 

​                                                                                        R2=[R1], R3=[R1+#4], R4=[R1+#8], R5=[R1+#12]

•堆栈寻址  stmfd sp!, {r2-r7, lr}                                  #  将r2到r7压栈，用于保存子程序现场

•相对寻址       beq flag



**ARM汇编特点3：指令后缀**

•同一指令经常附带不同后缀，变成不同的指令。经常使用的后缀有：

•B（byte）功能不变，操作长度变为8位

•H（half word）功能不变，长度变为16位

•S（signed）功能不变，操作数变为有符号

•如 ldr ldrb ldrh ldrsb ldrsh

•S（S标志）功能不变，影响CPSR标志位

•如 mov和movs  movs r0, #0



**ARM汇编特点4：条件执行后缀**

![条件执行后缀](https://i.loli.net/2019/04/08/5cab5a3a22e16.png)





**ARM汇编特点5：多级指令流水线**

•为增加处理器指令流的速度，ARM使用多级流水线.，下图为3级流水线工作原理示意图。（S5PV210使用13级流水线，ARM11为8级）

允许多个操作同时处理，而非顺序执行



![图片](https://i.loli.net/2019/04/08/5cab59d33dbab.png)







•PC指向正被取指的指令，而非正在执行的指令



**常用ARM指令1：数据处理指令**

•数据传输指令  mov mvn

•算术指令  add sub rsb adc sbc rsc 

•逻辑指令  and orr eor bic

•比较指令  cmp cmn tst teq

•乘法指令  mvl mla umull umlal smull smlal

前导零计数  clz



**常用ARM指令2：cpsr，spsr访问指令**

•mrs & msr

•mrs用来读psr，msr用来写psr

•CPSR寄存器比较特殊，需要专门的指令访问，这就是mrs和msr。



**常用ARM指令3：跳转(分支)指令**

•b & bl & bx

•

•b 直接跳转（就没打开算返回）

•bl branch and link，跳转前把返回地址放入lr中，以便返回，以便用于函数调用

•bx跳转同时切换到ARM模式，一般用于异常处理的跳转。



**常用ARM指令4：访存指令**

•ldr/str &  ldm/stm & swp

•

•单个字/半字/字节访问 ldr/str

•多字批量访问  ldm/stm

•swp r1, r2, [r0]

swp r1, r1, [r0]



**ARM汇编中的立即数**

•合法立即数与非法立即数

因为ARM中只有几个位是用来保存数字的，其他都是命令位



•ARM指令都是32位，除了指令标记和操作标记外，本身只能附带很少位数的立即数。因此立即数有合法和非法之分。

•合法立即数：经过任意位数的移位后非零部分可以用8位表示的即为合法立即数



**协处理器cp15操作指令**

•mcr & mrc



•mrc用于读取CP15中的寄存器

•mcr用于写入CP15中的寄存器

**协处理器**

•SoC内部另一处理核心，协助主CPU实现某些功能，被主CPU调用执行一定任务。

•ARM设计上支持多达16个协处理器，但是一般SoC只实现其中的CP15.（cp：coprocessor）

•协处理器和MMU、cache、TLB等处理有关，功能上和操作系统的虚拟地址映射、cache管理等有关。



**MRC & MCR的使用方法**

•mcr{<cond>}   p15, <opcode_1>, <Rd>, <Crn>, <Crm>, {<opcode_2>}

•opcode_1：对于cp15永远为0

•Rd：ARM的普通寄存器

•Crn：cp15的寄存器，合法值是c0～c15

•Crm：cp15的寄存器，一般均设为c0

•opcode_2：一般省略或为0

协处理器的寄存器有很多，并且很复杂，遇到的时候去百度即可



**多寄存器访问指令**

•ldr/str每周期只能访问4字节内存，如果需要批量读取、写入内存时太慢，解决方案是stm/ldm

例子：

•stmia  sp, {r0 - r12}

•将r0存入sp指向的内存处（假设为0x30001000）；然后地址+4（即指向0x30001004），将r1存入该地址；然后地址再+4（指向0x30001008），将r2存入该地址······直到r12内容放入（0x3001030），指令完成。

•一个访存周期同时完成13个寄存器的读写



**8种后缀**

•ia（increase after）先传输，再地址+4

•ib（increase before）先地址+4，再传输

•da（decrease after）先传输，再地址-4

•db（decrease before）先地址-4，再传输

•fd（full decrease）满递减堆栈

•ed（empty decrease）空递减堆栈

•fa（·······） 满递增堆栈

ea（……）空递增堆栈





四种栈

•空栈：栈指针指向空位，每次存入时可以直接存入然后栈指针移动一格；而取出时需要先移动一格才能取出

•满栈：栈指针指向栈中最后一格数据，每次存入时需要先移动栈指针一格再存入；取出时可以直接取出，然后再移动栈指针

•增栈：栈指针移动时向地址增加的方向移动的栈

•减栈：栈指针移动时向地址减小的方向移动的栈

**！的作用**

•ldmia  r0, {r2 - r3}

•ldmia  r0！, {r2 - r3}



•感叹号的作用就是r0的值在ldm过程中发生的增加或者减少最后写回到r0去，也就是说ldm时会改变r0的值。



**^的作用**

•ldmfd  sp!, {r0 - r6, pc}

•ldmfd  sp!, {r0 - r6, pc}^



•^的作用：在目标寄存器中有pc时，会同时将spsr写入到cpsr，一般用于从异常模式返回。



**gnu汇编中的一些符号**

•@ 用来做注释。可以在行首也可以在代码后面同一行直接跟，和C语言中//类似

•# 做注释，一般放在行首，表示这一行都是注释而不是代码。

•：以冒号结尾的是标号

•.  点号在gnu汇编中表示当前指令的地址

•# 立即数前面要加#或$，表示这是个立即数



**常用gnu伪指令**

•.global _start  @ 给_start外部链接属性

•.section .text  @ 指定当前段为代码段

•.ascii .byte .short .long .word 

•.quad .float .string @ 定义数据

•.align 4  @ 以16字节对齐

•.balignl 16 0xabcdefgh   @ 16字节对齐填充

•.equ  @ 类似于C中宏定义



•.end  @标识文件结束

•.include  @ 头文件包含

•.arm / .code32  @声明以下为arm指令

•.thumb / .code16  @声明以下为thubm指令



**最重要的几个伪指令**

•ldr  大范围的地址加载指令

•adr  小范围的地址加载指令

•adrl  中等范围的地址加载指令

•nop  空操作



•ARM中有一个ldr指令，还有一个ldr伪指令

•一般都使用ldr伪指令而不用ldr指令