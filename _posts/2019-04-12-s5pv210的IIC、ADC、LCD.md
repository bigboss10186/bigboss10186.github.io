---
layout:     post
title:      s5pv210的IIC、ADC、触摸屏和LCD
subtitle:   ARM
date:       2019-04-12
author:     BY 孟超
header-img: img/arm.jpg
catalog: 	 true
tags:
    - arm
---



# 1、I2C总线信号时序

**总线空闲状态**
　　I2C总线总线的SDA和SCL两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。

 ![](http://hi.csdn.net/attachment/201110/17/0_1318854337VggW.gif)

**启动信号**
　　在时钟线SCL保持高电平期间，数据线SDA上的电平被拉低（即负跳变），定义为I2C总线总线的启动信号，它标志着一次数据传输的开始。启动信号是一种电平跳变时序信号，而不是一个电平信号。启动信号是由主控器主动建立的，在建立该信号之前I2C总线必须处于空闲状态。

 

**重启动信号**
　　在主控器控制总线期间完成了一次数据通信（发送或接收）之后，如果想继续占用总线再进行一次数据通信（发送或接收），而又不释放总线，就需要利用重启动Sr信号时序。重启动信号Sr既作为前一次数据传输的结束，又作为后一次数据传输的开始。利用重启动信号的优点是，在前后两次通信之间主控器不需要释放总线，这样就不会丢失总线的控制权，即不让其他主器件节点抢占总线。

 

**停止信号**
　　在时钟线SCL保持高电平期间，数据线SDA被释放，使得SDA返回高电平（即正跳变），称为I2C总线的停止信号，它标志着一次数据传输的终止。停止信号也是一种电平跳变时序信号，而不是一个电平信号，停止信号也是由主控器主动建立的，建立该信号之后，I2C总线将返回空闲状态。

    不是在数据有效性中规定在SDA只能在SCL的低电平的时候变化，为何STAR，STOP不一样？首先STAR和STOP不是数据，所以可以不遵守数据有效性中的规定，其它数据都遵守，而STAR和STOP“不遵守”导致STAR和STOP更容易被识别。这样不是不遵守而是更有优势。
    
    起始和停止条件一般由主机产生，总线在起始条件后被认为处于忙的状态，在停止条件的某段时间后总线被认为再次处于空闲状态。
    
    如果产生重复起始(Sr) 条件而不产生停止条件，总线会一直处于忙的状态。此时的起始条件(S)和重复起始(Sr) 条件在功能上是一样的。 
    如果连接到总线的器件合并了必要的接口硬件，那么用它们检测起始和停止条件十分简便。但是没有这种接口的微控制器在每个时钟周期至少要采样SDA 线两次来判别有没有发生电平切换。

![](http://hi.csdn.net/attachment/201110/17/0_1318853970OkrL.gif)

**数据位传送**
　　在I2C总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在SCL串行时钟的配合下，在SDA上逐位地串行传送每一位数据。进行数据传送时，在SCL呈现高电平期间，SDA上的电平必须保持稳定，低电平为数据0，高电平为数据1。只有在SCL为低电平期间，才允许SDA上的电平改变状态。逻辑0的电平为低电压，而逻辑1的电平取决于器件本身的正电源电压VDD（当使用独立电源时）。数据位的传输是边沿触发。



 ![](http://hi.csdn.net/attachment/201110/17/0_1318853905BPbB.gif)

**应答信号**
　　I2C总线上的所有数据都是以8位字节传送的，发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。 应答信号为低电平时，规定为有效应答位（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。 对于反馈有效应答位ACK的要求是，接收器在第9个时钟脉冲之前的低电平期间将SDA线拉低，并且确保在该时钟的高电平期间为稳定的低电平。 如果接收器是主控器，则在它收到最后一个字节后，发送一个NACK信号，以通知被控发送器结束数据发送，并释放SDA线，以便主控接收器发送一个停止信号P。



 ![](http://hi.csdn.net/attachment/201110/17/0_1318854048Qqtb.gif)

**插入等待时间**
　　如果被控器需要延迟下一个数据字节开始传送的时间，则可以通过把时钟线SCL电平拉低并且保持，使主控器进入等待状态。一旦被控器释放时钟线，数据传输就得以继续下去，这样就使得被控器得到足够时间转移已经收到的数据字节，或者准备好即将发送的数据字节。带有CPU的被控器在对收到的地址字节做出应答之后，需要一定的时间去执行中断服务子程序，来分析或比较地址码，其间就把SCL线钳位在低电平上，直到处理妥当后才释放SCL线，进而使主控器继续后续数据字节的发送。

![](http://hi.csdn.net/attachment/201110/17/0_1318854240DAbN.gif)

 

**总线封锁状态**  
　　在特殊情况下，如果需要禁止所有发生在I2C总线上的通信活动，封锁或关闭总线是一种可行途径，只要挂接于该总线上的任意一个器件将时钟线SCL锁定在低电平上即可。

 

**总线竞争的仲裁**
        总线上可能挂接有多个器件，有时会发生两个或多个主器件同时想占用总线的情况，这种情况叫做总线竞争。I2C总线具有多主控能力，可以对发生在SDA线上的总线竞争进行仲裁，其仲裁原则是这样的：当多个主器件同时想占用总线时，如果某个主器件发送高电平，而另一个主器件发送低电平，则发送电平与此时SDA总线电平不符的那个器件将自动关闭其输出级。总线竞争的仲裁是在两个层次上进行的。首先是地址位的比较，如果主器件寻址同一个从器件，则进入数据位的比较，从而确保了竞争仲裁的可靠性。由于是利用I2C总线上的信息进行仲裁，因此不会造成信息的丢失。

         为何识别到“0”将丢失仲裁呢？因为对于OD门，只能驱动到低电平，释放总线只能通过不驱动总线释放，停止驱动即产生“1”，但是发现总线还是“0”，这说明还有主机在跟自己竞争总线使用权，自己线驱动到“1”，确检测到“0”，那代表自己已经失去了仲裁。

主机只能在总线空闲的时侯启动传送。两个或多个主机可能在起始条件的最小持续时间tHD;STA 内产生一个起始条件，结果在总线上产生一个规定的起始条件。
当SCL 线是高电平时，仲裁在SDA 线发生；这样，在其他主机发送低电平时，发送高电平的主机将断开它的数据输出级，因为总线上的电平与它自己的电平不相同。然后，进一步获得其的判定条件：
仲裁可以持续多位。首先是比较地址位。如果每个主机都试图寻址同一的器件，仲裁会继续比较数据位（假设主机是发送器），或者比较响应位（假设主机是接收器）。
I2C 总线的地址和数据信息由赢得仲裁的主机决定，在仲裁过程中不会丢失信息。丢失仲裁的主机可以产生时钟脉冲直到丢失仲裁的该字节末尾。
在串行传输过程中时，一旦有重复的起始条件或停止条件发送到I2C 总线的时侯，仲裁过程仍在进行。如果可能产生这样的情况，有关的主机必须在帧格式相同位置发送这个重复起始条件或停止条件。 
此外，如果主机也结合了从机功能，而且在寻址阶段丢失仲裁，它很可能就是赢得仲裁的主机在寻址的器件。那么，丢失仲裁的主机必须立即切换到它的从机模式。
I2C 总线的控制只由地址或主机码以及竞争主机发送的数据决定，没有中央主机，总线也没有任何定制的优先权。

上图显示了两个主机的仲裁过程当然可能包含更多的内容由连接到总线的主机数量决定此时产生DATA1 的主机的内部数据电平与SDA 线的实际电平有一些差别如果关断数据输出这就意味着总线连接了一个高输出电平这不会影响由赢得仲裁的主机初始化的数据传输。



![](http://hi.csdn.net/attachment/201110/17/0_1318854914D30u.gif)

**时钟信号的同步** 
          在I2C总线上传送信息时的时钟同步信号是由挂接在SCL线上的所有器件的逻辑“与”完成的。SCL线上由高电平到低电平的跳变将影响到这些器件，一旦某个器件的时钟信号下跳为低电平，将使SCL线一直保持低电平，使SCL线上的所有器件开始低电平期。此时，低电平周期短的器件的时钟由低至高的跳变并不能影响SCL线的状态，于是这些器件将进入高电平等待的状态。当所有器件的时钟信号都上跳为高电平时，低电平期结束，SCL线被释放返回高电平，即所有的器件都同时开始它们的高电平期。其后，第一个结束高电平期的器件又将SCL线拉成低电平。这样就在SCL线上产生一个同步时钟。可见，时钟低电平时间由时钟低电平期最长的器件确定，而时钟高电平时间由时钟高电平期最短的器件确定。

![](http://hi.csdn.net/attachment/201110/17/0_13188546296ct1.gif)

**s5pv210中的IIC控制器**

通信双方本质上是通过时序在工作，但是时序会比较复杂不利于SoC软件完成，于是乎解决方案是SoC内部内置了硬件的控制器来产生通信时序。

这样我们写软件时只需要向控制器的寄存器中写入配置值即可，控制器会产生适当的时序在通信线上和对方通信。

**结构框图**

![](https://i.loli.net/2019/04/12/5caf69e569c59.png)

(1)时钟部分，时钟来源是PCLK_PSYS，经过内部分频最终得到I2C控制器的CLK，通信中这个CLK会通过SCL线传给从设备。

(2)I2C总线控制逻辑（前台代表是I2CCON、I2CSTAT这两个寄存器），主要负责产生I2C通信时序。实际编程中要发送起始位、停止位、接收ACK等都是通过这两个寄存器（背后所代表的电路模块）实现的。

(3)移位寄存器（shift register），将代码中要发送的字节数据，通过移位寄存器变成1个位一个位的丢给SDA线上去发送/接收。学过数字电路的同学应该对移位寄存器不陌生。

(4)地址寄存器+比较器。本I2C控制器做从设备的时候用。(我没用过，理论分析)



**系统分析I2C的时钟**

(1)I2C时钟源头来源于PCLK（PCLK_PSYS，等于65MHz），经过了2级分频后得到的。

(2)第一级分频是I2CCON的bit6，可以得到一个中间时钟I2CCLK（等于PCLK/16或者PCLK/512）

(3)第二级分频是得到最终I2C控制器工作的时钟，以I2CCLK这个中间时钟为来源，分频系数为[1,16]

(4)最终要得到时钟是2级分频后的时钟，譬如一个可用的设置是：65000KHz/512/4=31KHz



**主要寄存器I2CCON、I2CSTAT、I2CADD、I2CDS**

I2CCON + I2CSTAT：主要用来产生通信时序和I2C接口配置。

I2CADD：用来写自己的slave address

I2CDS：发送/接收的数据都放在这里



**I2C从设备的设备地址**

(1)KXTE9的I2C地址固定为0b0001111（0x0f）

(2)I2C从设备地址本身是7位的，但是在I2C通信中发送I2C从设备地址时实际发送的是8位，这8位中高7位（bit7-bit1）对应I2C从设备的7位地址，最低一位（LSB）存放的是R/W信息（就是说下一个数据是主设备写从设备读（对应0），还是主设备读从设备写（对应1））

(3)基于上面讲的，对于KXTE9来说，主设备（SoC）发给gsensor信息时，SAD应该是：0b00011110(0x1E)
如果是主设备读取gsensor信息时，SAD应该是：0b00011111（0x1F）



# 2、ADC

**ADC的引入**

1、什么是ADC

(1)ADC:analog digital converter,AD转换，模数转换（也就是模拟转数字）

(2)CPU本身是数字的，而外部世界变量（如电压、温度、高度、压力···）都是模拟的，所以需要用CPU来处理这些外部的模拟变量的时候就需要做AD转换。

2、为什么需要ADC

(1)为了用数字技术来处理外部的模拟物理量。

3、关于模拟量和数字量

(1)模拟的就是连续的，现实生活当中的时间、电压、高度等都是模拟的（连续分布的，划分的话可以无限的更小划分）。模拟量反映在数学里面就是无限小数位（从0到1之间有无数个数）

(2)数字的就是离散的，离线的就是不连续的。这种离散处理实际上是从数学上对现实中的模拟量的一种有限精度的描述。数字化就是离散化，就是把连续分布的模拟量按照一定精度进行取点（采样）变成有限多个不连续分布的数字值，就叫数字量。

(3)数字化的意义就在于可以用（离散）数学来简化描述模拟量，这东西是计算机技术的基础。

(4)计算机处理参量的时候都是数字化的，计算机需要数字化的值来参与运算。如果系统输入参数中有模拟量，就需要外加AD转换器将模拟量转成数字量再给计算机。

4、有AD自然就有DA

(1)AD是analog to digital，DA自然就是digital to analog，数字转模拟。

(2)纯粹用cpu是不可能实现数字转模拟，因为cpu本身就是数字的。使用一些（具有一些积分或微分效果的）物理器件就可实现数字转模拟。

(3)数字转模拟的作用。譬如可以用来做波形发生器。



**ADC的主要相关概念**

**1、量程（模拟量输入范围）**
(1)AD转换器是一个电子器件，所以他只能输入电压信号。其他种类的模拟信号要先经过传感器（Sensor）的转换变成模拟的电压信号然后才能
给AD。

(2)AD输入端的模拟电压要求有一个范围，一般是0～3.3V或0～5V或者是0～12V等等。模拟电压的范围是AD芯片本身的一个参数。实际工作时给AD的

电压信号不能超过这个电压范围。



**2、精度（分辨率resolution）**

(1)AD转换输出的数字值是有一定的位数的（譬如说10位，意思就是输出的数字值是用10个二进制位来表示的，这种就叫10位AD）。这个位数就表示了转换精度。

(2)10位AD就相当于把整个范围分成了1024个格子，每个格子之间的间隔就是电压的表示精度。加入AD芯片的量程是0～3.3V，则每个格子代表的电压值是3.3V/1024=0.0032265V。如果此时AD转换后得到的数字量是447，则这个数字量代表的模拟值是：447×0.0032265V=1.44V。

(3)AD的位数越多，则每个格子表示的电压值越小，将来算出来的模拟电压值就越精确。

(4)AD的模拟量程一样的情况下，AD精度位数越多精度越高，测出来的值越准。但是如果AD的量程不一样。
譬如2个AD，A的量程是0～50V，B的量程是0～0.5V，A是12位的，B是10位的，可能B的精度比A的还要高。（
A的精度：50/1024=0.04883，B的精度：0.5/4096=0.000122）

**3、转换速率（MSPS与conventor clock的不同）**

(1)首先要明白：AD芯片进行AD转换是要耗费时间的。这个时间需要多久，不同的芯片是不一样的，同一颗芯片在配置不一样（譬如说精度配置为10位时时间比精度配置为12位时要小，譬如说有些AD可以配转换时钟，时钟频率高则转换时间短）时转换时间也不一样。

(2)详细的需要时间可以参考数据手册。一般数据手册中描述转换速率用的单位是MSPS（第一个M是兆，S是sample，就是采样；PS就是per second，总的意思就是兆样本每秒，每秒种转出来多少M个数字值）

(3)AD工作都需要一个时钟，这个时钟有一个范围，我们实际给他配置时不要超出这个范围就可以了。AD转换是在这个时钟下进行的，时钟的频率控制着AD转换的速率。注意：时钟频率和MSPS不是一回事，只是成正比不是完全相等。譬如S5PV210中的AD转换器，MSPS = 时钟频率/5

**4、通道数**

(1)AD芯片有多少路analog input通道，代表了将来可以同时进行多少路模拟信号的输入。



**S5PV210的ADC控制器**

1、ADC和（电阻式）触摸屏的关系

(1)ADC在210的数据手册的Section10.7

(2)电阻式触摸屏本身工作时依赖于AD转换，所以在210的SoC中电阻触摸屏接口本身和ADC接口是合二为一的。
或者说电阻触摸屏接口使用了（复用了）ADC的接口。

2、ADC的工作时钟框图

(1)ADCCLK是ADC控制器工作的时钟，也就是1.13.2.3节中讲到的conventor clock。从时钟框图可以看出，它是PCLK（当然是PCLK_PSYS）经过了一次分频后得到的。所以将来初始化ADC控制器时一定有一个步骤是初始化这里的分频器。

3、210的10个ADC通道（注意ADC引脚和GPIO的区别）

(1)210一共支持10个ADC通道，分别叫AIN[0]~AIN[9]。理论上可以同时做10路AD转换。

(2)SoC的引脚至少分2种：digit数字引脚和analog模拟引脚。我们以前接触的GPIO都属于数字引脚，ADC channel通道引脚属于模拟引脚。

数字引脚和模拟引脚一般是不能混用的。



4、ADC控制器的主要寄存器

TSADCCON0

TSDATX0  TSDATY0		转出来的AD值存在这里，我们读也是读这里

CLRINTADC0				清中断

ADCMUX					选择当前正在操作的AD通道

(1)等待触摸屏转换完毕的方法有2种：一种是检查标志位，第二种是中断。第一种方式下我们先开启一次转换然后循环不停检查标志位直到标志位为1表明已经转换完可以去读了；第二种方式下就是设置好中断，写好中断isr来读取AD转换数据。然后开启中断后CPU就不用管了，等AD转换完成后会生成一个中断信号给CPU，就会进入中断处理流程。第一种方法是同步的，第二种方式是异步的。

(2)AD转换都是需要反复进行的，那么转完一次一般要立即开启下一次转换，所以需要有一种机制能够在一次转完时自动开启下一次。这个机制就叫start by read，这个机制的工作方法是：当我们读取本次AD转换的AD值后，硬件自动开启下一次AD转换。

# 3、LCD

1：LCD基本工作原理

(1)　　LCD（Liquid Crystal Display）液晶显示，液晶特性：在电信号的驱动下液晶分子进行旋转，旋转会影响透光性，因此整个液晶面板

后面用白光（背光）来照射，通过不同的电信号让液晶分子进行旋转性透光，此时液晶面板就会看到显示不同的颜色。液晶本身不发光，而是

位于后面的背光发的光。

(2)　　白光是由多种颜色的光组合而成，光的实质是一种波，不同波长/频率的波具有不同的颜色，人眼可见光波长在390~780NM，RGB色彩模式是工业界的一种颜色标准，

是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视

力所能感知的所有颜色，是目前运用最广的颜色系统之一。

(3)　　210控制器可以采用RGB888颜色编码模式，红绿蓝各8位，红色绿色蓝色又称为三原色光，用英文表示就是R(red)、G(green)、B(blue)。在电脑中，RGB的所谓“多少”

就是指亮度，并使用整数来表示。通常情况下，RGB各有256级亮度，用数字表示为从0、1、2...直到255。共256级。计算机所能表达的颜色种类个数，这个参数叫：像素深度bpp。

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115123817431-731476278.png)

 (4)　　　LCD显示图像原理：LCD屏幕是由一个个像素点组成的矩阵(如resolution 1024*768，横向有1024个像素点，纵向有768个

像素点)，每个像素点都可以被单独控制亮或者不亮或者亮度强弱等，LCD图像就是通过不同的颜色强度的像素点组合而成。我们可采用RGB888编码来表示每个像素

点的颜色模式（强弱、颜色等等），一帧数据就表示在LCD矩阵的每个像素点对应的颜色模式。

(5)　　SoC如何控制LCD显示原理：

　　LCD驱动器：LCD驱动器一般与LCD面板集成在一起，面板需要一定的模拟电信号来控制液晶分子，LCD驱动器芯片负责给面板提供控制液晶分子的模拟电

信号，驱动器的控制信号（数字信号）来自于LCD控制器的提供的接口。

　　LCD控制器：LCD控制器集成在SoC内部，它负责通过数字接口向外部的LCD驱动器提供要显示的像素数字信号。它必须按照一定的时序和LCD驱动器通信，LCD

控制器受SoC控制，SoC会从内存中拿出像素数据给LCD控制器并最终传给LCD驱动器。

　　显存：SoC在内存中选一段内存，用来存放颜色数据，然后通过配置将LCD控制器和这一段内存连接起来，构成一个映射关系，一旦这个关系建立以后

，LCD控制器就会自动从显存中读取像素数据传给LCD驱动器，LCD驱动器会自动的控制每个像素点的液晶分子，以形成最终的图像，建立这个映射以后

就不需要SoC在来参与任何行为了。

　　总结一下：SoC控制LCD液晶显示的过程分为两个部分：

　　　　(1) SoC的LCD控制器引出一定的引脚与LCD驱动器连接，按照标准设置一定的时序;

　　　　(2) 把LCD要显示的像素信息放入内存中，在通过设置LCD控制器中的寄存器，与LCD控制器建立映射；

之后过程就是LCD控制器芯片与驱动器芯片自动完成的事情了，整个LCD图像的显示过程就是这样。

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115132411697-255906184.png)

 

(6)　　LCD接口技术：从电平角度来讲LCD都是TTL电平，TTL缺陷是容易受到外界影响，传输距离近，一般像手机平板等直接用软排线

连接即可，而远距离则需要转换，转换方式为：TTL--》VGA--》TTL。

(7)　　补充

虚拟屏幕叠加：

(1)虚拟屏幕的意思是，我们平时看到的屏幕上显示出来的场景实际是很多个屏幕显示叠加在一起的效果（譬如新闻图像、电视台台标、下方飘动的字幕新闻）
(2)像S5PV210的LCD控制器中有5个虚拟屏幕Window0到Window4，虚拟屏幕不存在于真实而存在于内存中。（之前讲过，LCd显示时实际是显示的是对应的内存中的显存区域的数值）

虚拟屏幕其实就是一个内存中的显存区域，有几个显存区域就有几个虚拟屏幕，但是这些虚拟屏幕都被映射到一个真实的显示屏上面，所以将来真实的现实效果实际是这几个虚拟屏幕的显示内容的叠加。

（叠加时要注意上面一层会覆盖下面一层，所以要注意谁在前谁在后，设置寄存器时有这个选项）
(3)使用虚拟屏幕而不是整个LCD使用一个显存是有一定好处的：第一，可以保证不污染源图像，方便程序处理；第二，可以减少屏幕刷新，提高显示效率，减少CPU工作量。

虚拟显示

(1)如何实现在小分辨率的屏幕上（真实）显示大分辨率的图像
(2)细节上，我们需要屏幕上看到不同图像时，需要对显存区域进行刷新。即使我们只需要屏幕显示移动一点点，整个屏幕对应的显存空间也需要整个重新刷新，工作量和完全重新显示一幅图像是一样的。

这个显然不好，这样CPU刷新屏幕的工作量太大了，效率很低。
(3)如何能够在显示一个大图片的不同区域时让CPU刷新屏幕工作量减少？有，方法就是虚拟显示。具体做法就是在内存中建立显示缓存的时候实际建立一个很大的区域，然后让LCD去对应其中的一部分

区域作为有效的显示区域。将来要显示大图像时，直接将大图像全部一次性加载入显示缓存区，然后通过移动有效显示区域就可以显示大图像的不同区域了。

 

2：S5PV210 LCD时序

看一下核心板原理图：LCD接线为24条VD数据输出线，用来传输RGB888 24位颜色数据，VCLK时钟线，HSYNC：水平同步信号线；VSYNC：垂直同步信号线，VDEN：数据使能线；

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115135314072-2093682437.png)

 

HSPW+1：HSYNC线上不工作是为低电平，拉高HSPW+1时钟，在拉低，表示要准备开始传输颜色数据；（这个时间可以理解为切换到下一行所消耗的时间）

HBPD+1：在经过HBPD+1时钟，VDEN线拉高，表示VD线上之后的都是RGB颜色数据，所以只有当VDEN信号线为高电平是，才认为是发送的真实数据，

开始发送水平颜色信息以后就会连续发送，如1024*768分辨率LCD，会一直把水平的1024个像素点的颜色数据都发送完以后才会拉低VDEN。（这个时间理解为

准备传输水平数据所要消耗时间）

HOZVAL+1：1024-1不表示时钟，而是表示水平像素个数-1

表示传输横线颜色数据的总时钟，如一个时钟频率传输1个bit位，每个颜色数据设置为32位，横向共传输1024个b颜色数据，总的时钟为1024*32；

HFPD+1：数据传输完以后首先把VDEN拉低HFPD+1时钟，整个水平传输周期完成；（这个时间可以理解为，结束数据传输所消耗时间）

VSPW+1：同样可以理解为切换整帧图像数据所消耗时间；

VBPD+1：准备传输整帧数据消耗时间；

LINEVAL+1：768-1；

VFPD+1：结束传输整帧数据的同步时间；

​      要注意，这几个时序参数本身是LCD屏幕本身的参数，与LCD控制器无关。所以同一个主板如果接的屏幕不一样则时序参数设置也会不同。

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115134728760-1440309393.png)

 3：相关寄存器

寄存器：DISPAY_CONTROL 设置为10或11；RGB模式可行即可；

![img](https://images2015.cnblogs.com/blog/1052746/201702/1052746-20170203111738011-1885162254.png)

 

VIDCON0：Video Main Control 0 Register

bit18-26选择为RGB模式

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115145732213-1636142360.png)

bit18：设置RGB数据传输为并行还是串行，因为有24根数据线所以为并行；

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115145920728-2138176231.png)

bit2选择时钟源，选HCLK 连的是HCLC_DSYS 为166MHz

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115150424260-268588151.png)

bit4：开启分频；

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115151029306-880512121.png)

 

bit13-6设置时钟大小，时钟频率要小于控制器的最大时钟，也要小于LCD驱动器的最大时钟。

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115150822900-1593463582.png)

 

bit0 bit1为使能控制信号都使能

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115150653150-211266467.png)

VIDCON1寄存器 Video Main Control 1 Register

bit5 bit6设置HSYNC和VSYNC的极性，如果LCD的高低电平脉冲是相同的话，则Normal，如果极性相反则Invert。

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115151224619-1374925674.png)

VIDTCON0：设置时序，根据LCD数据手册中的时序来设置

 ![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115153506291-117308098.png)

VIDTCON1

 ![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115153537556-1271933594.png)

VIDTCON2

 ![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115153604963-1853806886.png)

WINCON0寄存器

bit1：使能window0 

 ![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115153712103-120357156.png)

bit5-2选择RGB888模式

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115153745588-223532092.png)

bit15：设置输出顺序为 red green blue还是 blue green red　 设置为1：BGR　　设置为0：RGB

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115153859838-2008938693.png)

VIDOSD0A VIDOSD0B这两个寄存器是用来设置内存中window0的大小；

比如设置为LCD屏幕的尺寸（即左上坐标为(0, 0) 右下坐标为(1023, 767)）

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115154448556-1860132381.png)

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115154515760-559197856.png)

VIDOSD0C也是设置内存中window0的大小

比如设置为LCD屏幕的尺寸=1024*768

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115154626447-1229317940.png)

VIDW0xADD0Bx设置内存中window0的起始地址的

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115154956963-487040547.png)

VIDW0xADD1Bx设置内存中window0的结束地址的

 ![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115155058385-1529452154.png)

 SHODOWCON寄存器来设置虚拟windows显示的；

以下位可以分别设置哪个windows显示；

![img](https://images2015.cnblogs.com/blog/1052746/201701/1052746-20170115155452775-1322630653.png)

补充：看核心板、地板原理图相应引脚要设置为LCD的引脚模式，LCD背光要打开；

 

以下位详细代码：

 

```c
#include "lyq.h"
#define     _ZLS_MODE_
#define RED             (0xFF0000)
#define GREEN            (0x00FF00)
#define BLUE            (0x0000FF)
#define WHITE            (0xFFFFFF)
    

//配置相关引脚
#define    GPF0CON            0xE0200120
#define    GPF1CON            0xE0200140
#define    GPF2CON            0xE0200160
#define    GPF3CON            0xE0200180
#define GPD0CON            0xE02000A0
#define GPD0DAT            0xE02000A4
#define DISPLAY_CONTROL        0xE0107008

//配置控制器
#define VIDCON0            0xF8000000
#define VIDTCON0        0xF8000010
#define VIDCON1            0xF8000004
#define VIDTCON1        0xF8000014
#define VIDTCON2        0xF8000018
#define WINCON0            0xF8000020
#define VIDOSD0A        0xF8000040
#define VIDOSD0B        0xF8000044
#define VIDOSD0C        0xF8000048
#define VIDW00ADD0B0    0xF80000A0
#define VIDW00ADD1B0    0xF80000D0
#define SHODOWCON        0xF8000034

#define    _RGB_GPF0CON    (*(unsigned int*)0xE0200120)
#define    _RGB_GPF1CON    (*(unsigned int*)0xE0200140)
#define    _RGB_GPF2CON    (*(unsigned int*)0xE0200160)
#define    _RGB_GPF3CON    (*(unsigned int*)0xE0200180)
#define    _RGB_GPD0CON    (*(unsigned int*)0xE02000A0)
#define    _RGB_GPD0DAT    (*(unsigned int*)0xE02000A4)
#define    _RGB_DISPLAY_CONTROL    (*(unsigned int*)0xE0107008)

//配置控制器
#define    _RGB_VIDCON0    (*(unsigned int*)0xF8000000)
#define    _RGB_VIDTCON0    (*(unsigned int*)0xF8000010)
#define    _RGB_VIDCON1    (*(unsigned int*)0xF8000004)
#define    _RGB_VIDTCON1    (*(unsigned int*)0xF8000014)
#define    _RGB_VIDTCON2    (*(unsigned int*)0xF8000018)
#define    _RGB_WINCON0    (*(unsigned int*)0xF8000020)
#define    _RGB_VIDOSD0A    (*(unsigned int*)0xF8000040)
#define    _RGB_VIDOSD0B    (*(unsigned int*)0xF8000044)
#define    _RGB_VIDOSD0C    (*(unsigned int*)0xF8000048)
#define    _RGB_VIDW00ADD0B0    (*(unsigned int*)0xF80000A0)
#define    _RGB_VIDW00ADD1B0    (*(unsigned int*)0xF80000D0)
#define    _RGB_SHODOWCON    (*(unsigned int*)0xF8000034)

#define FB_ADDR            (0x23000000)

//Horizontal Pulse Width        20
//Horizontal Back Porch            140
//Horizontal Front Porch           160    
//Horizontal effective Time        1024
    
//Vertical Pulse Width            3
//Vertical Back Porch            20
//Vertical Front Porch            12
//Vertical Valid                600

#ifdef                    _ZLS_MODE_
#define HSPW             (40)                // 1~40 DCLK
#define HBPD            (10 - 1)            // 46
#define HFPD             (240 - 1)            // 16 210 354
#define VSPW            (20)                // 1~20 DCLK
#define VBPD             (10 - 1)            // 23
#define VFPD             (30 - 1)            // 7 22 147
#else 
#define HSPW             (20)                // 1~40 DCLK
#define HBPD            (140)            // 46
#define HFPD             (160)            // 16 210 354
#define VSPW            (3)                // 1~20 DCLK
#define VBPD             (20)            // 23
#define VFPD             (12)            // 7 22 147
#endif

#define ROW                (600)
#define COL                (1024)
#define FB_ADDR            (0x23000000)
#define HOZVAL            (COL-1)
#define LINEVAL            (ROW-1)
#define LeftTopX        (0)
#define LeftTopY        (0)
#define RightBotX        (COL - 1)
#define RightBotY        (ROW - 1)
unsigned int *pfb = (unsigned int *)FB_ADDR;



void lcd_init(void)
{
    //设置相应引脚为LCD模式
    _RGB_GPF0CON = 0x22222222;
    _RGB_GPF1CON = 0x22222222;
    _RGB_GPF2CON = 0x22222222;
    _RGB_GPF3CON = 0x22222222;
    
    //设置背光开启，输出低电平
    _RGB_GPD0CON &= ~(0xF << 0);
    _RGB_GPD0CON |= (0x1 << 0);
    _RGB_GPD0DAT &= ~(0x1 << 0);
    
    //设置FIMD的输出为RGB模式输出
    _RGB_DISPLAY_CONTROL &= ~(3 << 0);
    _RGB_DISPLAY_CONTROL |= (2 << 0);
    
    
    //基本设置
    _RGB_VIDCON0 &= ~(0x3 << 26);                //设置为RGB模式
    _RGB_VIDCON0 &= ~(0x1 << 18);                //设置为RGB并行
    _RGB_VIDCON0 &= ~(0x1 << 2);                //设置时钟源为HCLK_DSYS
    _RGB_VIDCON0 |= (1 << 4);                    //开启分频    
    _RGB_VIDCON0 &= ~(0xFF << 6);                //设置时钟分频为4 166/(4+1) = 33
    _RGB_VIDCON0 |=    (4 << 6);
    _RGB_VIDCON0 |= (3 << 0);                    //使能signal

    
    _RGB_VIDCON1 |= (3 << 5);                    //开启HSYNC、VSYNC极性反转
    
    //设置时序等
    _RGB_VIDTCON0 &= ~(0xFFFFFF << 0);
    _RGB_VIDTCON0 |= ((VSPW << 0) | (VFPD << 8) | (VBPD) << 16);
    
    _RGB_VIDTCON1 &= ~(0xFFFFFF << 0);
    _RGB_VIDTCON1 |= ((HSPW << 0) | (HFPD << 8) | (HBPD) << 16);
    
    _RGB_VIDTCON2 = ((HOZVAL << 0) | (LINEVAL << 11));
    
    //设置window0
    _RGB_WINCON0 |= (1 << 0);                    //使能window0
    _RGB_WINCON0 &= ~(0xF << 2);                //设置window0位RGB888模式
    _RGB_WINCON0 |= (0xB << 2);
    
    //设置window0在内存中的坐标
    _RGB_VIDOSD0A &= ~(0x3FFFFF << 0);
    _RGB_VIDOSD0A |= ((LeftTopX << 0) | (LeftTopX << 11));
    _RGB_VIDOSD0B &= ~(0x3FFFFF << 0);
    _RGB_VIDOSD0B |= ((RightBotY << 0) | (RightBotX << 11));
    _RGB_VIDOSD0C = (RightBotX + 1) * (RightBotY + 1);

    //设置显存的起始地址
    _RGB_VIDW00ADD0B0 = (unsigned int)FB_ADDR;    
    
    //设置显存结束地址
    //_RGB_VIDW00ADD1B0 = (((HOZVAL )*4 + 0) * (LINEVAL + 1)) & (0xffffff);
    _RGB_VIDW00ADD1B0 = _RGB_VIDW00ADD0B0 + (((HOZVAL + 1)*4 + 0) * (LINEVAL + 1));
    
    //使能channel0
    _RGB_SHODOWCON = 1;
    
}



static void lcd_point_draw_func(unsigned int x, unsigned int y, unsigned int color)
{
    
    unsigned int mem_val, i;
    
    mem_val = (unsigned int)FB_ADDR + (COL*(y-1) + (x-1)) * sizeof(int);
    *(unsigned int *)mem_val = color;    
    
}

void clean_window(void)
{
    int i = 0;
    
    for (i=0; i<614400; i++) {
        *pfb = 0;
        pfb++;
        
    }
    
}

static void lcd_bckgrd_draw(unsigned int color)
{
    int i, j;
    
    for (j=0; j<ROW; j++) {
        for (i=0; i<COL; i++) {
            lcd_point_draw_func(i, j, color);
        }
    }
    
}

static void lcd_line_draw(unsigned int y, unsigned int color)
{
    int i = 0;
    for (i=0; i<1024; i++) {
        lcd_point_draw_func(i, (y-1), color);
    }    
}

void lcd_pic_draw(const unsigned char *pcolor)
{
    int i, j;
    int color;
    
    for (j=0; j<ROW; j++) {
        for (i=0; i<COL; i++) {
            color = ((*pcolor) << 0) | ((*(pcolor+1)) << 8) | ((*(pcolor+2)) << 16);
            lcd_point_draw_func(i, j, color);
            pcolor +=3; 
        }
}
}
// 在像素点(x, y)处填充为color颜色
/*
static inline void lcd_draw_pixel(unsigned int x, unsigned int y, unsigned int color)
{
    *(pfb + COL * y + x) = color;
}

// 把整个屏幕全部填充成一个颜色color
static void lcd_draw_background(unsigned int color)
{
    unsigned int i, j;
    
    for (j=0; j<ROW; j++)
    {
        for (i=0; i<COL; i++)
        {
            lcd_draw_pixel(i, j, color);
        }
    }
}


*/

void lcd_test(void)
{    
        lcd_init();
        //clean_window();
        //lcd_bckgrd_draw(RED);
        //delay();
        lcd_pic_draw(gImage_lyq);    
}
```