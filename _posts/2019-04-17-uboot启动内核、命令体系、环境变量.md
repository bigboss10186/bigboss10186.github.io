---
layout:     post
title:      uboot启动内核、命令体系、环境变量
subtitle:   uboot
date:       2019-04-17
author:     BY 孟超
header-img: img/H12kIfHnM.jpg
catalog: 	 true
tags:
    - uboot

---

uboot和linux都可以算是一个裸机程序，只不过是一个比较复杂庞大的裸机程序。

# 1、启动linux内核

uboot第二阶段完成后，会将linux kernel加载到DDR中，如果SD卡中有kernel，则用movi read kernel 30008000来启动，如果我们SD卡中没有，我们可以通过tftp的方式从远端服务器获取镜像进行下载。

将kernel弄到DDR特定位置之后，可以用bootm 30008000进行跳转执行内核

**镜像要放在DDR的什么地址？**

内核一定要放在链接地址处，链接地址去内核源代码的链接脚本或者Makefile中去查找。X210中是0x30008000。



**vmlinuz和zImage和uImage**

(1)uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是可以直接执行的。但是这种格式不能用来烧录下载。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的）得到的。这个u-boot.
bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。

(2)linux内核经过编译后也会生成一个elf格式的可执行程序，叫vmlinux或vmlinuz，这个就是原始的未经任何处理加工的原版内核elf文件；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫Image（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。

(3)原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的前端附加了一部分解压缩代码。构成了一个压缩格式的镜像就叫zImage。（因为当年Image大小刚好比一张
软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。

(4)uboot为了启动linux内核，还发明了一种内核格式叫uImage。uImage是由zImage加工得到的，uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。这个加工过程其实就是在zImage前面加上64字节的uImage的头信息即可。

(4)原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。但是所有的uboot肯定都支持uImage启动。

**镜像的entrypoint**

(1)ep就是entrypoint的缩写，就是程序入口。一个镜像文件的起始执行部分不是在镜像的开头（镜像开头有n个字节的头信息），真正的镜像文件执行时第一句代码在镜像的中部某个字节处，相当于头是有一定的偏移量的。这个偏移量记录在头信息中。

(2)一般执行一个镜像都是：第一步先读取头信息，然后在头信息的特定地址找MAGIC_NUM，由此来确定镜像种类；第二步对镜像进行校验；第三步再次读取头信
息，由特定地址知道这个镜像的各种信息（镜像长度、镜像种类、入口地址）；第四步就去entrypoint处开始执行镜像。

(3)theKernel = (void (*)(int, int, uint))ep;将ep赋值给theKernel，则这个函数指向就指向了内存中加载的OS镜像的真正入口地址（就是操作系统的第一句执行的代码）。

**机器码的再次确定**

uboot在启动内核时，机器码要传给内核。uboot传给内核的机器码是怎么确定的？第一顺序备选是环境变量machid，第二顺序备选是gd->bd->bi_arch_num（x210_sd.h中硬编码配置的）



# 2、uboot的命令体系

uboot中每一个命令对应一个函数，比如fastboot命令就对应的函数是do_fastboot函数。

**uboot命令解析和执行过程分析**

**从main_loop说起**

(1)uboot启动的第二阶段，在初始化了所有该初始化的东西后，进入了一个死循环，死循环的循环体就是main_loop。

(2)main_loop函数执行一遍，就是一个获取命令、解析命令、执行命令的过程。

(3)run_command函数就是用来执行命令的函数。

**run_command函数详解**

(1)控制台命令获取 

(2)命令解析。parse_line函数把"md 30000000 10"解析成argv[0]=md, argv[1]=30000000 argv[2]=10;

(3)命令集中查找命令。find_cmd(argv[0])函数去uboot的命令集合当中搜索有没有argv[0]这个命令，

(4)执行命令。最后用函数指针的方式调用执行了对应函数。

**uboot中也可以自己添加命令，非常方便简答**



# 3、uboot中的环境变量

**环境变量的优先级**

(1)uboot代码当中有一个值，环境变量中也有一个值。uboot程序实际运行时规则是：如果环境变量为空则使用代码中的值；如果环境变量不为空则优先使用环境变量对应的值。

(2)譬如machid（机器码）。uboot中在x210_sd.h中定义了一个机器码2456，写死在程序中的不能更改。如果要修改uboot中配置的机器码，可以修改x210_sd.h中的机器码，但是修改源代码后需要重新编译烧录，很麻烦；比较简单的方法就是使用环境变量machid。set machid 0x998类似这样，有了machid环境变量后，系统启动时会优先使用machid对应的环境变量，这就是优先级问题。



**环境变量原理**

(1)默认环境变量，在uboot/common/env_common.c中default_environment，这东西本质是一个字符数组，大小为CFG_ENV_SIZE（16kb），里面内容就是很多个环境变量连续分布组成的，每个环境变量最末端以'\0'结束。

(2)SD卡中环境变量分区，在uboot的raw分区中。SD卡中其实就是给了个分区，专门用来存储而已。存储时其实是把DDR中的环境变量整体的写入SD卡中分区里。所以当我们saveenv时其实整个所有的环境变量都被保存了一遍，而不是只保存更改了的。

(3)DDR中环境变量，在default_environment中，实质是字符数组。在uboot中其实是一个全局变量，链接时在数据段，重定位时default_environment就被重定位到DDR中一个内存地址处了。这个地址处这个全局字符数组就是我们uboot运行时的DDR中的环境变量了。



总结：刚烧录的系统中环境变量分区是空白的，uboot第一次运行时加载的是uboot代码中自带的一份环境变量，叫默认环境变量。我们在saveenv时DDR中的环境变量会被更新到SD卡中的环境变量中，就可以被保存下来，下次开机会在环境变量relocate时会SD卡中的环境变量会被加载到DDR中去。