---
layout:     post
title:      linux线程
subtitle:   linux API
date:       2019-04-29
author:     BY 孟超
header-img: img/post-bg-swift.jpg
catalog: 	 
tags:
    - linux API
---

# Linux线程

再论进程

1、多进程实现同时读取键盘和鼠标

上一个文章中写了许多关于同时读写键盘和鼠标的代码，这里我们用这种方式实现一下，说明我们为什么要引入线程。

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>



int main(void)
{
	// 思路就是创建子进程，然后父子进程中分别进行读键盘和鼠标的工作
    
	int ret = -1;
	int fd = -1;
	char buf[200];
	
	ret = fork();
	if (ret == 0)
	{
		// 子进程
        
		fd = open("/dev/input/mouse1", O_RDONLY);
		if (fd < 0)
		{
			perror("open:");
			return -1;
		}
		
		while (1)
		{
			memset(buf, 0, sizeof(buf));
			printf("before read.\n");
			read(fd, buf, 50);
			printf("读出鼠标的内容是：[%s].\n", buf);
		}	
	}
	else if (ret > 0)
	{
		// 父进程
        
		while (1)
		{
			memset(buf, 0, sizeof(buf));
			printf("before read.\n");
			read(0, buf, 5);
			printf("读出键盘的内容是：[%s].\n", buf);			
		}
	}
	else
	{
		perror("fork:");
	}
	
	return 0;
}


```



**使用进程技术的优势**

(1)CPU时分复用，单核心CPU可以实现宏观上的并行

(2)实现多任务系统需求（多任务的需求是客观的）

**进程技术的劣势**

(1)进程间切换开销大

(2)进程间通信麻烦而且效率低、

**解决方案就是线程技术**

(1)线程技术保留了进程技术实现多任务的特性。

(2)线程的改进就是在线程间切换和线程间通信上提升了效率。

(3)多线程在多核心CPU上面更有优势。

**linux中的线程简介**

(1)一种轻量级进程

(2)线程是参与内核调度的最小单元

(3)一个进程中可以有多个线程

**线程技术的优势**

(1)像进程一样可被OS调度

(2)同一进程的多个线程之间很容易高效率通信

(3)在多核心CPU（对称多处理器架构SMP）架构下效率最大化



**线程常见函数**

**1、线程创建与回收**

| 函数名         | 作用                                                 |
| -------------- | ---------------------------------------------------- |
| pthread_create | 主线程用来创造子线程的                               |
| pthread_join   | 主线程用来等待（阻塞）回收子线程                     |
| pthread_detach | 主线程用来分离子线程，分离后主线程不必再去回收子线程 |

**2、线程取消**

| 函数名                 | 作用                                               |
| ---------------------- | -------------------------------------------------- |
| pthread_cancel         | 一般都是主线程调用该函数去取消（让它赶紧死）子线程 |
| pthread_setcancelstate | 子线程设置自己是否允许被取消                       |
| pthread_setcanceltype  |                                                    |

**3、线程函数退出相关**

| 函数名               | 作用                     |
| -------------------- | ------------------------ |
| pthread_exit         | 退出                     |
| return               | 退出                     |
| pthread_cleanup_push | 这两个函数貌似和堆栈有关 |
| pthread_cleanup_pop  |                          |

**4、获取线程id**

pthread_self

**线程同步之信号量**

1、任务：用户从终端输入任意字符然后统计个数显示，输入end则结束

使用多线程实现：主线程获取用户输入并判断是否退出，子线程计数

其实可以不用多线程来实现这个任务，但是我们只是用这个例子来演示多线程的使用方法



**信号量的介绍和使用**

信号量涉及到的函数，直接在程序中看吧

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>


char buf[200] = {0};
sem_t sem;
unsigned int flag = 0;


// 子线程程序，作用是统计buf中的字符个数并打印

void *func(void *arg)
{
	// 子线程首先应该有个循环
    
    
	// 循环中阻塞在等待主线程激活的时候，子线程被激活后就去获取buf中的字符
    
	// 长度，然后打印；完成后再次被阻塞
    
	sem_wait(&sem);
	//while (strncmp(buf, "end", 3) != 0)
	while (flag == 0)
	{	
		printf("本次输入了%d个字符\n", strlen(buf));
		memset(buf, 0, sizeof(buf));
		sem_wait(&sem);
	}
	
	
	pthread_exit(NULL);
}


int main(void)
{
	int ret = -1;
	pthread_t th = -1;
	
	
	
	sem_init(&sem, 0, 0);
	
	ret = pthread_create(&th, NULL, func, NULL);
	if (ret != 0)
	{
		printf("pthread_create error.\n");
		exit(-1);
	}
	
	printf("输入一个字符串，以回车结束\n");
	while (scanf("%s", buf))
	{
		// 去比较用户输入的是不是end，如果是则退出，如果不是则继续	
        
		if (!strncmp(buf, "end", 3))
		{
			printf("程序结束\n");
			flag = 1;
			sem_post(&sem);	
			//exit(0);
			break;
		}
		
		// 主线程在收到用户收入的字符串，并且确认不是end后
        
		// 就去发信号激活子线程来计数。
        
		// 子线程被阻塞，主线程可以激活，这就是线程的同步问题。
        
		// 信号量就可以用来实现这个线程同步
        
		sem_post(&sem);	
	}

	
	// 回收子线程
    
	printf("等待回收子线程\n");
	ret = pthread_join(th, NULL);
	if (ret != 0)
	{
		printf("pthread_join error.\n");
		exit(-1);
	}
	printf("子线程回收成功\n");
	
	sem_destroy(&sem);
	
	return 0;
}



```




**互斥锁**

(1)互斥锁又叫互斥量（mutex）

(2)相关函数：

pthread_mutex_init pthread_mutex_destroy 

pthread_mutex_lock pthread_mutex_unlock

(3)互斥锁和信号量的关系：可以认为互斥锁是一种特殊的信号量

(4)互斥锁主要用来实现关键段保护

用互斥锁来实现的代码

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>



char buf[200] = {0};
pthread_mutex_t mutex;
unsigned int flag = 0;


// 子线程程序，作用是统计buf中的字符个数并打印

void *func(void *arg)
{
	// 子线程首先应该有个循环
    
	// 循环中阻塞在等待主线程激活的时候，子线程被激活后就去获取buf中的字符
    
	// 长度，然后打印；完成后再次被阻塞
    
	
	//while (strncmp(buf, "end", 3) != 0)
    
	sleep(1);
	while (flag == 0)
	{	
		pthread_mutex_lock(&mutex);
		printf("本次输入了%d个字符\n", strlen(buf));
		memset(buf, 0, sizeof(buf));
		pthread_mutex_unlock(&mutex);
		sleep(1);
	}
	
	
	pthread_exit(NULL);
}


int main(void)
{
	int ret = -1;
	pthread_t th = -1;
	
	
	
	pthread_mutex_init(&mutex, NULL);
	
	ret = pthread_create(&th, NULL, func, NULL);
	if (ret != 0)
	{
		printf("pthread_create error.\n");
		exit(-1);
	}
	
	printf("输入一个字符串，以回车结束\n");
	while (1)
	{
		pthread_mutex_lock(&mutex);
		scanf("%s", buf);
		pthread_mutex_unlock(&mutex);
		// 去比较用户输入的是不是end，如果是则退出，如果不是则继续	
        
		if (!strncmp(buf, "end", 3))
		{
			printf("程序结束\n");
			flag = 1;
			
			//exit(0);
			break;
		}
		sleep(1);
		// 主线程在收到用户收入的字符串，并且确认不是end后
        
		// 就去发信号激活子线程来计数。
        
		// 子线程被阻塞，主线程可以激活，这就是线程的同步问题。
        
		// 信号量就可以用来实现这个线程同步
        
	}

	
	// 回收子线程
    
	printf("等待回收子线程\n");
	ret = pthread_join(th, NULL);
	if (ret != 0)
	{
		printf("pthread_join error.\n");
		exit(-1);
	}
	printf("子线程回收成功\n");
	
	pthread_mutex_destroy(&mutex);
	
	return 0;
}



```



注意：man 3 pthread_mutex_init时提示找不到函数，说明你没有安装pthread相关的man手册。安装方法：1、虚拟机上网；2、sudo apt-get install manpages-posix-dev

**线程同步之条件变量**

什么是条件变量

相关函数

​		pthread_cond_init		pthread_cond_destroy

​		pthread_cond_wait		pthread_cond_signal/pthread_cond_broadcast



使用条件变量来实现代码

条件变量和互斥锁之间有一定的关联。

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>



char buf[200] = {0};
pthread_mutex_t mutex;
pthread_cond_t cond;
unsigned int flag = 0;


// 子线程程序，作用是统计buf中的字符个数并打印

void *func(void *arg)
{
	// 子线程首先应该有个循环
    
	// 循环中阻塞在等待主线程激活的时候，子线程被激活后就去获取buf中的字符
    
	// 长度，然后打印；完成后再次被阻塞
	
	//while (strncmp(buf, "end", 3) != 0)
    
	//sleep(1);
    
	while (flag == 0)
	{	
		pthread_mutex_lock(&mutex);
		pthread_cond_wait(&cond, &mutex);
		printf("本次输入了%d个字符\n", strlen(buf));
		memset(buf, 0, sizeof(buf));
		pthread_mutex_unlock(&mutex);
		//sleep(1);
	}
	
	
	pthread_exit(NULL);
}


int main(void)
{
	int ret = -1;
	pthread_t th = -1;
	

	pthread_mutex_init(&mutex, NULL);
	pthread_cond_init(&cond, NULL);
	
	ret = pthread_create(&th, NULL, func, NULL);
	if (ret != 0)
	{
		printf("pthread_create error.\n");
		exit(-1);
	}
	
	printf("输入一个字符串，以回车结束\n");
	while (1)
	{
		//pthread_mutex_lock(&mutex);
        
		scanf("%s", buf);
		pthread_cond_signal(&cond);
		//pthread_mutex_unlock(&mutex);
        
		// 去比较用户输入的是不是end，如果是则退出，如果不是则继续	
        
		if (!strncmp(buf, "end", 3))
		{
			printf("程序结束\n");
			flag = 1;
			
			//exit(0);
			break;
		}
        
		//sleep(1);
        
		// 主线程在收到用户收入的字符串，并且确认不是end后
        
		// 就去发信号激活子线程来计数。
        
		// 子线程被阻塞，主线程可以激活，这就是线程的同步问题。
        
		// 信号量就可以用来实现这个线程同步
        
	}

	
	// 回收子线程
    
	printf("等待回收子线程\n");
	ret = pthread_join(th, NULL);
	if (ret != 0)
	{
		printf("pthread_join error.\n");
		exit(-1);
	}
	printf("子线程回收成功\n");
	
	pthread_mutex_destroy(&mutex);
	pthread_cond_destroy(&cond);
	
	return 0;
}


```

