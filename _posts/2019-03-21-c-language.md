---
layout:     post
title:      c语言
subtitle:   C语言
date:       2019-03-21
author:     BY 孟超
header-img: img/post-bg-ios9-web.jpg
catalog: 	 true
tags:
    - c语言
---

# C语言

***学C语言一定要和内存结合起来，这样才能更好的解决更多的问题***

### （1）补码的基础

#### 计算机的基石补码

对于一个字节（8 位），他所能表示的范围有多大呢？答案是共 256（2的八次方）种。 内存模型也和下图差不多，可以这样理解。（计算机中地址编码的基本单位是字节）

![捕获.PNG](https://i.loli.net/2019/03/21/5c9371a918e04.png)

在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路 。

![补码](https://i.loli.net/2019/03/21/5c9375011c067.png)

补码中第一位数字是0 的则为正数，值为其本身，但是第一位是负数 的话，就是负数，它的值的绝对值是其按位取反并加1，是其绝对值。比如11111111 他是负数，按位取反后是00000000，再加一是00000001，所以值为-1.补码是其他的基础，有了补码也会更好的理解int，char等数据类型。

有一道世界500强企业的面试题，问为什么char类型的范围是[-128,127]，而不是[-128,128]?

答案就应该是由于编码规则导致的.

### （2）数据类型及 const 

int、float、double、char

应该知道的一点是不同平台上的int是占据的字节数是不一定的，C语言并没有规定，是由编译器决定的，但是C语言规定了short<=int <=long

但是一般的平台都是int占四个字节，，int默认是有符号书，所以当int占四个字节的时候，int的取值范围就是[-65536,65535]就是负的2的16次方到正2的16次方减1（根据补码知识就很容易明白了）

C语言中float占四个字节，double占八个字节，C语言中float取值范围是-3.4×10^38~3.4×10^38

单精度浮点数float，他有一位符号位，指数位占八位，尾数23位，float和double的精度是靠尾数位来决定的。

C语言规定float<=double <=long double 具体字节数由编译器决定（好像float是固定的四个字节，不确定）



#### 下面说一下浮点数类型中的那个坑

① 在用这段代码的时候printf("%f",10/3);时，打印出来应该是0.000000，而不是3.333333

应该这样做才对printf("%f",(float)10/3);必须强制类型转化一下才行。才能打印出来3..333333

#### 浮点数与0的比较（浮点数的范围是无线趋近于0的）

```c
#include <stdio.h>
int main()
{
    double tmp=0.3;
    printf("%d",tmp*10);
    return 0;
}
```

这段代码打出来不是3，会打印成2，因为这个tmp在内存中存储的可能是0.299999，不是0.3，当tmp=0.7的时候也是，会打印出来6，因为按照%d格式打印，小数点后面直接舍去

我们需要这样写

```c
#include <stdio.h>
int main()
{
    double tmp=0.3;
    printf("%d",(int)(tmp+0.000001)*10);
    return 0;
}
```



这样才对，这叫修正值。

#### const

下面说说const这货

const是常变量，修饰的值不可改变，但是实际上，在C语言中这是假的，const修饰的变量是可以修改的，可以通过指针修改。

```c
const int a = 4;
int *pi =&a;

*pi=4;

printf("%d",a);
```

下面说说指针类型的const

int const *pi;这是一个指向整形常量的指针，可以修改指针的值，但是不能修改它所指向的值.

int * const  pi ;这个是一个指向整形的常量指针，可以修改它所指向的值，但是不能修改指针的值。

int const * const pi ;这就是上边两种的综合了，都不可以修改.

### （3）类型转换

#### 隐式类型转换

**算术转化**
在进行运算时，以表达式中最长类型为主，将其他类型位据均转换成该类型 。默认转换的

**赋值转化**
整型和实型之间是可以相互赋值的。赋值的原则是，一个是加零，一个是去小数位。 

#### 强制类型转化
int a=（int）3.333;

### （4）运算符优先级相关问题

数组下标运算符，（）运算符 ，结构体中的.成员运算符，->运算符优先级最高

还有注意运算符的结合性

如在**while((ch=getchar())!=EOF);**这句话中ch=getchar()两边必须要有（）

### （5）进程空间（包括变量的存储位置，生命周期）

进程空间

![进程空间](https://i.loli.net/2019/03/21/5c9384e32d284.png)

全局变量：不初始化的默认为0，放在.bss段，初始化为0的也放在.bss段

​		   初始化为非0的全局变量放在.data段中，生命周期全局

局部变量放在栈上，当调用结束，生命周期结束

### （6）各种指针详解

#### （1）指针数组

指针数组，是个数组，里边放的东西都是指针。char *p[2]={"china","linux"};

#### （2）数组指针

数组指针，是个指针，指向数组的指针.

```c
int a[2][5]={0};
int (*p)[5]=a;
```



#### （3）函数指针

```c
int (*p)(int a,char b);//函数指针p指向返回值类型为int的，两个参数为int和char的函数
```



void *类型可以指向任何一个类型的指针



void (*signal(int sig, void (*func) (int))) (int)

**signal仍然是一个函数**，他返回一个函数指针，这个指针指向的函数没有返回值，只有一个int类型的参数

#### 插一个二维数组
```c
a[5][7];//用指针访问就是*（*（p+5）+7）
```

### （7）函数参数问题

##### ①函数参数是一维数组

```c
int func(int a[]);
int func(int *a);//等价
```

##### ②函数参数是二维数组

```
int func(int a[][5]);//后面的那个大小必须写
int func(int (*p)[5]);//参数指向二维数组,就像一个int变量，传参数传的是int*，是个指针一样

```

##### ③函数参数是指针数组

```c
int func(char *c[5]);
int func(char **c);
```

##### ④函数参数是二重指针

```c

int func(char**c);
```



### （8）函数递归与迭代

递归：循环次数太多，容易将栈压爆，产生错误，要避免这种错误；递归直接明了，迭代的代码不容易看懂

例如斐波那契数列用迭代是个很不错的选择

### （9）字符数组与指向字符串指针的问题

其中char \*p="linux" 这种情况字符串Linux只存在于只读数据段中（rodata），所以p所指向的内容不可以被更改，如\*（p+1）=a;这是实现不了的，但是可以更改指针p 指向的地址，例如p="mengchao",但是这里的p="mengchao"这段话放在子函数中是不可以的，字符串mengchao是存在于栈中，子函数结束就被释放了，不能够达到改变的目的。可以使用二重指针来实现。

char p[]="linux" 这个是字符数组，相当于初始化数组，可以更改内容，如p[1]='a';* 这里Linux存在于栈上



**所以有的字符串操作函数例如chat *strcat(char *dst,char const *src);前面的参数dst只能传数组，不能直接传一个字符串，因为不可改变***



### （10）可变参数

可变参数由类型 va_list，一组宏va_start，va_arg，va_end实现。宏的实现根据编译器而有所不同。

在头文件stdarg.h中

```c
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>

int Add(int num, ...)
{
    int sum = 0;
    va_list arg;				//用于访问参数列表不确定的部分
    va_start(arg, num);			//初始化上面的边浪

    for (int i = 0; i < num; i++)
    {
        sum += va_arg(arg, int);	//访问参数，接收两个参数，上面的变量和参数列表中下一个参数的类型
    }

    va_end(arg);	//访问完毕，调用这个宏
    return sum;
}
int main()
{
    printf("%d\n", Add(4, 2, 3, 4, 5));
    system("pause");
    return 0;
}
```



### （11）文件操作

​	文本文件： 以 ASCII 码格式存放， 一个字节存放一个字符。 文本文件的每一个字节存放一个 ASCII 码， 代表一个字符。 这便于对字符的逐个处理， 但占用存储空间较多， 而且要花费时间转换。
​	二进制文件： 以值（ 补码） 编码格式存放。 二进制文件是把数据以二进制数的格式存放在文件中的， 其占用存储空间较少。 数据按其内存中的存储形式原样存放。 

###### FILE 结构体
FILE 结构体是对缓冲区和文件读写状态的记录者，所有对文件的操作，都是通过FILE 结构体完成的。

```c
typedef struct {
	short level; 			/* 缓冲区满/空程度 */
	unsigned flags; 		/* 文件状态标志 */
	char fd; 				/* 文件描述符 */
	unsigned char hold; 	/* 若无缓冲区不读取字符 */
	short bsize; 			/* 缓冲区大小 */
	unsigned char *buffer; 	/* 数据传送缓冲区位置 */
	unsigned char *curp; 	/* 当前读写位置 */
	unsigned istemp; 		/* 临时文件指示 */
	short token;	 		/* 用作无效检测 */
} FILE ; 				/* 结构体类型名 FILE * 
```

**（1）fopen（）函数：打开文件**

包含头文件：#include<stdio.h>

格式：FILE * fopen(const char * path,const char * mode);

参数：

 path：需要打开的文件路径
  mode：文件打开方式

r	以只读方式打开文件，该文件必须存在。  
r+	以可读写方式打开文件，该文件必须存在。  
rb+	读写打开一个二进制文件，允许读数据。  
rt+	读写打开一个文本文件，允许读和写。  
w	打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。  
w+	打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。  
a	以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留 ）  
a+	以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）  
wb	只写打开或新建一个二进制文件；只允许写数据。  
wb+	读写打开或建立一个二进制文件，允许读和写。  
wt+	读写打开或着建立一个文本文件；允许读写。  
at+	读写打开一个文本文件，允许读或在文本末追加数据。  

ab+	读写打开一个二进制文件，允许读或在文件末追加数据  



**fread（）函数和fwrite（）函数**


1.一般调用形式

  fread(buffer,size,count,fp);

  fwrite(buffer,size,count,fp);

2.说明

  （1）buffer：是一个指针，对fread来说，它是读入数据的存放地址。对fwrite来说，是要输出数据的地址。

  （2）size：要读写的字节数；

  （3）count:要进行读写多少个size字节的数据项；

**fgetc（）和fputc（）：字符读写函数**

fgetc函数(getc函数)
 (1)一般调用形式
        ch=fgetc(fp);
（2）作用
        从指定的文件读入一个字符，即从fp所指向的文件中读入一个字符赋给ch。
（3）返回值
        成功：返回值所得到的字符；
        失败：返回EOF(-1)。

putc函数（）

(1)一般调用形式
 fputc(ch,fp);
（2）作用
把一个字符写到磁盘文件上去，即将字符ch输出到fp所指向的文件中去。
（3）返回值
成功：返回值就是输出的字符；
失败：返回EOF(-1)。
说明：函数putchar()是在stdio.h中用预处理命令定义的宏，即：
#define putchar(c)     fputc(c,stdout)

**fgets（）和fputs（）函数：读写字符串函数**

（1）fgets（）：char *fgets（char *str, int num, FILE *fp） 

参数说明：str： 保存从文件读取出来的字符串       

         fp： 待读文件的文件指针
    
         num： 表示从文件中读出的字符串不超过 n-1个字符。在读入的最后一个字符后加上串结束标志'\0'

（2）fputs（char * s，FILE * stream）

**fclose(FILE *fp)**

关闭文件

### （12）缓冲区问题

缓冲区需要达到一定大小才会输出。一般是256个字节吧？记不清了，如果要想及时输出，可以通过换行运算符实现，或者在进程结束的时候会自动刷新，Linux好像进程结束也不自动刷新？（等待验证）

### （13）typedef及结构体，共用体，枚举

```c
struct stuff{

       char job[20];

       int age;

       float height;

}Huqinwei;        //定义结构体的同时，定义结构体变量Huqinwei
```



```c
typedef struct stuff{

       char job[20];

       int age;

       float height;

}stuff; //这样申请新的变量的时候可以用stuff A了，不然只能是struct stuff A；
```

结构体的对齐访问

```c
struct stuff{

       char c;

       int age;

}//应该是占据八个字节，而不是五个字节，四个字节对齐访问
```





### （14）内存操作函数malloc  free

不是讲基本操作的，讲自己遇到的问题

```c
void CreateList(SqList *&L,ElemType a[],int n)

{

int i;

L=(SqList *)malloc(sizeof(SqList));

for (i=0; i

L->data[i]=a[i];

L->length=n;

}
```

这里面传的第一个参数L，如果只用指针的话，函数结束就释放掉L了，导致分配的内存，根本找不回来，就是分配出去的以后也用不了了呀，因为给L分配了空间，但是L已经没了。如果只用引用&不方便，所以这里用*&，其实这里也可以用二重指针做参数，传L的地址&L。

因为这里是给参数分配内存所以不能只用*，给自己参数本身分配空间，只能这样

#### 变长数组问题
![数组](https://i.loli.net/2019/03/22/5c945e167d22b.png)

### （15）动态链接库及静态链接库

#### 自己制作静态链接库并使用
(1)第一步：自己制作静态链接库
	首先使用gcc -c只编译不连接，生成.o文件；然后使用ar工具进行打包成.a归档文件。库名不能随便乱起，一般是lib+库名称，后缀名是.a表示是一个归档文件
注意：制作出来了静态库之后，发布时需要发布.a文件和.h文件。

(2)第二步：使用静态链接库
	把.a和.h都放在我引用的文件夹下，然后在.c文件中包含库的.h，然后直接使用库函数。
编译方法：gcc test.c -o test -laston -L.
无报错，生成test，执行正确。

#### 自己制作动态链接库并使用
(1)动态链接库的后缀名是.so（对应windows系统中的dll），静态库的扩展名是.a
(2)第一步：创建一个动态链接库。
	gcc aston.c -o aston.o -c -fPIC
	gcc -o libaston.so aston.o -shared 
		-fPIC是位置无关码，-shared是按照共享库的方式来链接。
注意：做库的人给用库的人发布库时，发布libxxx.so和xxx.h即可。
(3)第二步：使用自己创建的共享库。
第一步，编译方法：gcc test.c -o test
报错信息：test.c:(.text+0xa): undefined reference to `func1'
test.c:(.text+0x1e): undefined reference to `func2'
collect2: error: ld returned 1 exit status

第二步，编译方法：gcc test.c -o test -laston
报错信息：/usr/bin/ld: cannot find -laston
collect2: error: ld returned 1 exit status

第三步，编译方法：gcc test.c -o test -laston -L.
编译成功

但是运行出错，报错信息：
error while loading shared libraries: libaston.so: cannot open shared object file: No such file or directory

错误原因：动态链接库运行时需要被加载（运行时环境在执行test程序的时候发现他动态链接了libaston.so，于是乎会去固定目录尝试加载libaston.so，如果加载失败则会打印以上错误信息。）

解决方法一：
将libaston.so放到固定目录下就可以了，这个固定目录一般是/usr/lib目录。
cp libaston.so /usr/lib即可

解决方法二：使用环境变量LD_LIBRARY_PATH。操作系统在加载固定目录/usr/lib之前，会先去LD_LIBRARY_PATH这个环境变量所指定的目录下去寻找，如果找到就不用去/usr/lib下面找了，如果没找到再去/usr/lib下面找。所以解决方案就是将libaston.so所在的目录导出到环境变量LD_LIBRARY_PATH中即可。
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/mnt/hgfs/Winshare/s5pv210/AdvancedC/4.6.PreprocessFunction/4.6.12.sharedobject.c/sotest

在ubuntu中还有个解决方案三，用ldconfig

(4)ldd命令：作用是可以在一个使用了共享库的程序执行之前解析出这个程序使用了哪些共享库，并且查看这些共享库是否能被找到，能被解析（决定这个程序是否能正确执行）。

### （16）static及extern详解

### static作用

 1、修饰变量

静态全局变量：全局变量前加static修饰，该变量就成为了静态全局变量。我们知道，全部变量在整个工程都可以被访问（一个文件中定义，其它文件使用的时候添加extern关键字声明 ），而在添加了static关键字之后，这个变量就只能在本文件内被访问了。因此，在这里，static的作用就是限定作用域。

静态局部变量：局部变量添加了static修饰之后，该变量就成为了静态局部变量。我们知道局部变量在离开了被定义的函数后，就会被销毁，而当使用static修饰之后，它的作用域就一直到整个程序结束。因此，在这里static的作用就是限定生命周期。

2、修饰函数

修饰函数则该函数成为静态函数，函数的作用域仅限于本文件，而不能被其它文件调用 

#### extern作用

1、函数的声明extern关键词是可有可无的，因为函数本身不加修饰的话就是extern。但是引用的时候一样需要声明的。

2、全局变量在外部使用声明时，extern关键字是必须的，如果变量没有extern修饰且没有显式的初始化，同样成为变量的定义，因此此时必须加extern，而编译器在此标记存储空间在执行时加载内并初始化为0。而局部变量的声明不能有extern的修饰，且局部变量在运行时才在堆栈部分分配内存。

3、全局变量或函数本质上讲没有区别，函数名是指向函数二进制块开头处的指针。而全局变量是在函数外部声明的变量。函数名也在函数外，因此函数也是全局的。

4、谨记：声明可以多次，定义只能一次。

5、extern int i; //声明，不是定义
int i; //声明，也是定义 

### （17）相关算法

```c

#include <stdio.h>
 
#define SIZE 10
int main()
{
    int a[SIZE]={12 ,43,9,13,67,98,101,89,3,35};//十个数的无序数列
    int i,j,t;
    printf("此程序使用冒泡排序法排列无序数列！\n");
    //冒泡排序
    for(i=0;i<10-1;i++)//n个数的数列总共扫描n-1次
    {
        for(j=0;j<10-i-1;j++)//每一趟扫描到a[n-i-2]与a[n-i-1]比较为止结束
        {
            if(a[j]>a[j+1])//后一位数比前一位数小的话，就交换两个数的位置（升序）
            {
               t=a[j+1];
               a[j+1]=a[j];
               a[j]=t;
            }
        }
    }
 
    printf("排列好的数列是：\n");
    //输出排列好得吃数列
    for(i=0;i<10;i++)
    {
 
        printf("%d ",a[i]);
    }
    return 0;
}
```



### （18）大小端模式

​	现在我们讲的这个大小端模式，更多是指计算机存储系统的大小端。在计算机内存/硬盘/Nnad中。因为存储系统是32位的，但是数据仍然是按照字节为单位的。于是乎一个32位的二进制在内存中存储时有2种分布方式：高字节对应高地址（大端模式）、高字节对应低地址（小端模式）
​	大端模式和小端模式本身没有对错，没有优劣，理论上按照大端或小端都可以，但是要求必须存储时和读取时按照同样的大小端模式来进行，否则会出错。
​	现实的情况就是：有些CPU公司用大端（譬如C51单片机）；有些CPU用小端（譬如ARM）。（大部分是用小端模式，大端模式的不算多）。



