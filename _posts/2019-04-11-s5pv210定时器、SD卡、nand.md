---
layout:     post
title:      s5pv210定时器、SD卡、nand
subtitle:   arm
date:       2019-04-11
author:     BY 孟超
header-img: img/arm.jpg
catalog: 	 true
tags:
    - arm
---



# 1、s5pv210中的定时器

在S5PV210内部，一共有4类定时器件。这4类定时器件的功能、特征是不同的。
**①PWM定时器**

(1)这种是最常用的，平时所说的定时器一般指的是这个。像简单单片机（譬如51单片机）中的定时器也是这类。

(2)为什么叫PWM定时器，因为一般SoC中产生PWM信号都是靠这个定时器模块的。

**②系统定时器**

(1)系统（指的是操作系统）定时器，系统定时器也是用来产生固定时间间隔（TCNT×时钟周期）信号的，称为systick，这个systick用来给操作系统提供tick信号。

(2)产生systick作为操作系统的时间片（time slice）的。

(3)一般做操作系统移植的时候，这里不会由我们自己来做，一般原厂提供的基础移植部分就已经包含了，所以这里我也从来没有研究过。

**③看门狗定时器**

(1)看门狗定时器本质上也是一个定时器，和上面2个没有任何本质区别。

(2)看门狗定时器可以设置在时间到了的时候产生中断，也可以选择发出复位信号复位CPU。

(3)看门狗定时器在实践中应用很多，尤其是工业领域（环境复杂、干扰多）机器容易出问题，而且出问题后后果很严重，此时一般都会用看门狗来进行系统复位。本章节会用2节课来对210中的看门狗进行讲解和编程。

**④实时时钟RTC（real time clock）**

(1)区分时间段和时间点。时间段是相对的，两个时间点相减就会得到一个时间段；而时间点是绝对的，是绝无仅有的一个时间点。

(2)定时器关注的是时间段（而不是时间点），定时器计时从开启定时器的那一刻开始，到定的时间段结束为止产生中断；RTC中工作用的是时间点（xx年x月x日x时x分x秒星期x）。

(3)RTC和定时器的区别，就相当于是钟表和闹钟的区别。







**PWM定时器介绍（数据手册的翻译）**

(1)S5PV210有5个PWM定时器。其中0、1、2、3各自对应一个外部GPIO，可以通过这些对应的GPIO产生PWM波形信号并输出；timer4没有对应的外部GPIO（因此不是为了生成PWM波形而是为了产生内部定时器中断而生的）

(2)S5PV210的5个PWM定时器的时钟源为PCLK_PSYS，timer0和timer1共同使用一个预分频器、timer2、3、4共同使用一个预分频器；每个timer有一个专用的独立的分频器；预分频器和分频器构成了2级分频系统，将PCLK_PSYS两级分频后生成的时钟供给timer模块作为时钟周期。



**S5PV210的PWM定时器框图简介**

![](https://i.loli.net/2019/04/11/5caf4bcb3858c.png)



关键点：时钟源、预分频器、分频器、TCMPB&TCNTB、dead zone

时钟源：可以是SCLK_PWM或者是PCLK_PSYS经过分频的时钟，从SCLK_PWM不用分频。

预分频器：就是上边的8BIT PRESCALER就是预分频器。这个预分频器会将你写在里边的数加1后作为分频系数，可能是为了防止你写个0，将CPU烧坏。

分频器：就是那个MUX选择的1/1、1/2、1/4等等。

TCMPB&TCNTB：就是相应的寄存器。

dead zone：死区生成器



**寄存器**

TCNT&TCMP、TCNTB&TCMPB、TCNTO

我们能够操作的只是TCNTB&TCMPB，而TCNT&TCMP是不可见的，TCNTO是为了读出来TCNT中的数。

(1)TCNT和TCNTB是相对应的，TCNTB是有地址的寄存器，供程序员操作；TCNT在内部和TCNTB相对应，它没有寄存器地址，程序员不能编程访问这个寄存器。

(2)TCNT寄存器功能就是用来减1的，它是内部的不能读写；我们向TCNT中写要通过TCNTB往进写；读取TCNT寄存器中的值要通过读取相对应的TCNTO寄存器。

(3)工作流程就是：我们事先算好TCNT寄存器中开始减的那个数（譬如300），然后将之写入TCNTB寄存器中，在启动timer前，将TCNTB中的值刷到TCNT寄存器中（有一位寄存器专门用来操作刷数据过去的），刷过去后就可以启动定时器开始计时；在计时过程中如果想知道TCNT寄存器中的值减到多少了，可以读取相应的TCNTO寄存器来得知。

(4)定时功能只需要TCNT、TCNTB两个即可；TCNTO寄存器用来做一些捕获计时；TCMPB用来生成PWM波形。

**自动重载和双缓冲（auto-reload and double buffering）**

(1)定时器工作的时候，一次定时算一个工作循环。定时器默认是单个循环工作的，也就是说定时一次，计时一次，到期中断一次就完了。下次如果还要再定时中断，需要另外设置。

(2)但是现实中用定时器来做的时候往往是循环的，最简单最笨的方法就是写代码反复重置定时器寄存器的值（在每次中断处理的isr中再次给TCNTB中赋值，再次刷到TCNT中再次启动定时器），早期的单片机定时器就是这样的；但是现在的高级SoC中的定时器已经默认内置了这种循环定时工作模式，就叫自动装载（auto-reload）机制。

(3)自动装载机制就是当定时器初始化好开始计时后再不用管了，他一个周期到了后会自己从TCNTB中再次装载值到TCNT中，再次启动定时器开始下个循环。

**输出电平翻转器**

由一个寄存器来控制的，具体看数据手册吧

(1)PWM定时器可以规定：当TCNT>TCMPB时为高电平，当TCNT<TCMPB时为低电平。也可以规定：当TCNT>TCMPB时为低电平，当TCNT<TCMPB时为高电平。在这两种规定下，计算时TCMP寄存器的值会变化。

(2)基于上面讲的，当duty从30%变到70%时，我们TCMPB寄存器中的值就要改（譬如TCNTB中是300时，TCMPB就要从210变化到90）。这样的改变可以满足需要，但是计算有点麻烦。于是乎210的PWM定时器帮我们提供了一个友好的工具叫做电平翻转器。

(3)电平翻转器在电路上的实质就是一个电平取反的部件，在编程上反映为一个寄存器位。写0就关闭输出电平反转，写1就开启输出电平反转。开启后和开启前输出电平刚好高低反转。（输出电平一反转30%的duty就变成70%了）

(4)实战中到底是TCNT和TCMPB谁大谁小时高电平还是低电平，一般不用理论分析，只要写个代码然后用示波器实际看一下出来的波形就知道了；如果反了就直接开启电平翻转器即可。



```c
#define 	GPD0CON		(0xE02000A0)
#define 	TCFG0		(0xE2500000)
#define 	TCFG1		(0xE2500004)
#define 	CON			(0xE2500008)
#define 	TCNTB2		(0xE2500024)
#define 	TCMPB2		(0xE2500028)

#define 	rGPD0CON	(*(volatile unsigned int *)GPD0CON)
#define 	rTCFG0		(*(volatile unsigned int *)TCFG0)
#define 	rTCFG1		(*(volatile unsigned int *)TCFG1)
#define 	rCON		(*(volatile unsigned int *)CON)
#define 	rTCNTB2		(*(volatile unsigned int *)TCNTB2)
#define 	rTCMPB2		(*(volatile unsigned int *)TCMPB2)


// 初始化PWM timer2，使其输出PWM波形：频率是2KHz、duty为50%

void timer2_pwm_init(void)
{
    
	// 设置GPD0_2引脚，将其配置为XpwmTOUT_2
    
	rGPD0CON &= ~(0xf<<8);
	rGPD0CON |= (2<<8);
	
	// 设置PWM定时器的一干寄存器，使其工作
    
	rTCFG0 &= ~(0xff<<8);
	rTCFG0 |= (65<<8);			// prescaler1 = 65, 预分频后频率为1MHz
    
	
	rTCFG1 &= ~(0x0f<<8);
	rTCFG1 |= (1<<8);			// MUX2设置为1/2,分频后时钟周期为500KHz
    
	// 时钟设置好，我们的时钟频率是500KHz，对应的时钟周期是2us。也就是说每隔2us
    
	// 计一次数。如果要定的时间是x，则TCNTB中应该写入x/2us
    
	
	rCON |= (1<<15);		// 使能auto-reload，反复定时才能发出PWM波形
    
	//rTCNTB2 = 250;			// 0.5ms/2us = 500us/2us = 250
    
	//rTCMPB2 = 125;			// duty = 50%
    
	
	rTCNTB2 = 50;			
	rTCMPB2 = 25;	
	
	// 第一次需要手工将TCNTB中的值刷新到TCNT中去，以后就可以auto-reload了
    
	rCON |= (1<<13);		// 打开自动刷新功能
    
	rCON &= ~(1<<13);		// 关闭自动刷新功能
    
	
	rCON |= (1<<12);		// 开timer2定时器。要先把其他都设置好才能开定时器
    
}


```

**S5PV210看门狗定时器的结构框图**



![](https://i.loli.net/2019/04/11/5caf55a85c840.png)



(1)PCLK_PSYS经过两级分频后生成WDT（watchdog timer）的时钟周期，然后把要定的时间写到WTDAT寄存器中，刷到WTCNT寄存器中去减1，减到0时（定时时间到）产生复位信号或中断信号。

(2)典型应用中是配置为产生复位信号，我们应该在WTCNT寄存器减到0之前给WTDAT寄存器中重新写值以喂狗。

**看门狗定时器的主要寄存器**

WTCON WTDAT WTCNT WTCLRINT

**看门狗定时器的编程实践**

可以产生中断信号，也可以产生复位信号，由一位寄存器设置

```c

#define		WTCON		(0xE2700000)
#define		WTDAT		(0xE2700004)
#define		WTCNT		(0xE2700008)
#define 	WTCLRINT	(0xE270000C)

#define 	rWTCON		(*(volatile unsigned int *)WTCON)
#define 	rWTDAT		(*(volatile unsigned int *)WTDAT)
#define 	rWTCNT		(*(volatile unsigned int *)WTCNT)
#define 	rWTCLRINT	(*(volatile unsigned int *)WTCLRINT)


// 初始化WDT使之可以产生中断

void wdt_init_interrupt(void)
{
    
	// 第一步，设置好预分频器和分频器，得到时钟周期是128us
    
	rWTCON &= ~(0xff<<8);
	rWTCON |= (65<<8);				// 1MHz
    
	
	rWTCON &= ~(3<<3);
	rWTCON |= (3<<3);				// 1/128 MHz, T = 128us
    
	
	// 第二步，设置中断和复位信号的使能或禁止
    
	rWTCON |= (1<<2);				// enable wdt interrupt
    
	rWTCON &= ~(1<<0);				// disable wdt reset
    
	
	// 第三步，设置定时时间
    
	// WDT定时计数个数，最终定时时间为这里的值×时钟周期
    
	//rWTDAT = 10000;					// 定时1.28s
    
	//rWTCNT = 10000;					// 定时1.28s
    
	
	// 其实WTDAT中的值不会自动刷到WTCNT中去，如果不显式设置WTCON中的值，它的值就是
    
	// 默认值，然后以这个默认值开始计数，所以这个时间比较久。如果我们自己显式的
    
	// 设置了WTCNT和WTDAT一样的值，则第一次的定时值就和后面的一样了。
    
	rWTDAT = 1000;					// 定时0.128s
    
	//rWTCNT = 1000;					// 定时0.128s
    
	
	// 第四步，先把所有寄存器都设置好之后，再去开看门狗
    
	rWTCON |= (1<<5);				// enable wdt
    
}


// wdt的中断处理程序

void isr_wdt(void)
{
	static int i = 0;
    
	// 看门狗定时器时间到了时候应该做的有意义的事情
    
	printf("wdt interrupt, i = %d...", i++);
	
	// 清中断
    
	intc_clearvectaddr();
	rWTCLRINT = 1;
}





```



**实时时钟RTC**

**何为实时时钟**

(1)real time clock，真实时间，就是所谓的xx年x月x日x时x分x秒星期x

(2)RTC是SoC中一个内部外设，RTC有自己独立的晶振提供RTC时钟源（32.768KHz），内部有一些寄存器用来记录时间（年月日时分秒星期）。一般情况下为了在系统关机时时间仍然在走，还会给RTC提供一个电池供电。

S5PV210实时时钟的结构框图

![](https://i.loli.net/2019/04/11/5caf5643ef1fe.png)



(1)时间寄存器7个

(2)闹钟发生器

**闹钟发生器**

(1)可以定闹钟时间，到时间会产生RTC alarm interrupt，通知系统闹钟定时到了。

(2)闹钟定时是定的时间点，而timer定时是定的时间段。



**S5PV210实时时钟的主要寄存器**

(1)INTP 中断挂起寄存器

(2)RTCCON	RTC控制寄存器

(3)RTCALM ALMxxx	闹钟功能有关的寄存器

(4)BCDxxx   时间寄存器



**BCD码**

(1)RTC中所有的时间（年月日时分秒星期，包括闹钟）都是用BCD码编码的。

(2)BCD码本质上是对数字的一种编码。用来解决这种问题：由56得到0x56（或者反过来）。也就是说我们希望十进制的56可以被编码成56（这里的56不是十进制56，而是两个数字5和6）.

(3)BCD码的作用在于可以将十进制数拆成组成这个十进制数的各个数字的编码，变成编码后就没有位数的限制了。譬如我有一个很大的数123456789123456789，如果这个数纯粹当数字肯定超出了int的范围，计算机无法直接处理。要想让计算机处理这个数，计算机首先得能表达这个数，表达的方式就是先把这个数转成对应的BCD码（123456789123456789）

(4)BCD码在计算机中可以用十六进制的形式来表示。也就是说十进制的56转成BCD码后是56，在计算机中用0x56来表达（暂时存储与运算）。

(5)需要写2个函数，一个是bcd转十进制，一个是十进制转bcd。当我们要设置时间时（譬如要设置为23分），我们需要将这个23转成0x23然后再赋值给相应的寄存器BCDMIN；当我们从寄存器BCDMIN中读取一个时间时（譬如读取到的是0x59），需要将之当作BCD码转成十进制再去显示（0x59当作BCD码就是59，转成十进制就是59，所以显示就是59分）。

```c
#include "main.h"

#define 	RTC_BASE	 (0xE2800000)
#define		rINTP      	 (*((volatile unsigned long *)(RTC_BASE + 0x30)))
#define		rRTCCON    	 (*((volatile unsigned long *)(RTC_BASE + 0x40)))
#define		rTICCNT    	 (*((volatile unsigned long *)(RTC_BASE + 0x44)))
#define		rRTCALM    	 (*((volatile unsigned long *)(RTC_BASE + 0x50)))
#define		rALMSEC    	 (*((volatile unsigned long *)(RTC_BASE + 0x54)))
#define		rALMMIN    	 (*((volatile unsigned long *)(RTC_BASE + 0x58)))
#define		rALMHOUR  	 (*((volatile unsigned long *)(RTC_BASE + 0x5c)))
#define		rALMDATE     (*((volatile unsigned long *)(RTC_BASE + 0x60)))
#define		rALMMON    	 (*((volatile unsigned long *)(RTC_BASE + 0x64)))
#define		rALMYEAR  	 (*((volatile unsigned long *)(RTC_BASE + 0x68)))
#define		rRTCRST      (*((volatile unsigned long *)(RTC_BASE + 0x6c)))
#define		rBCDSEC    	 (*((volatile unsigned long *)(RTC_BASE + 0x70)))
#define		rBCDMIN   	 (*((volatile unsigned long *)(RTC_BASE + 0x74)))
#define		rBCDHOUR     (*((volatile unsigned long *)(RTC_BASE + 0x78)))
#define		rBCDDATE     (*((volatile unsigned long *)(RTC_BASE + 0x7c)))
#define		rBCDDAY      (*((volatile unsigned long *)(RTC_BASE + 0x80)))
#define		rBCDMON      (*((volatile unsigned long *)(RTC_BASE + 0x84)))
#define		rBCDYEAR     (*((volatile unsigned long *)(RTC_BASE + 0x88)))
#define		rCURTICCNT   (*((volatile unsigned long *)(RTC_BASE + 0x90)))
#define		rRTCLVD    	 (*((volatile unsigned long *)(RTC_BASE + 0x94)))


// 函数功能：把十进制num转成bcd码，譬如把56转成0x56

static unsigned int num_2_bcd(unsigned int num)
{
	// 第一步，把56拆分成5和6 
    
	// 第二步，把5和6组合成0x56
    
	return (((num / 10)<<4) | (num % 10));
}

// 函数功能：把bcd码bcd转成十进制，譬如把0x56转成56

static unsigned int bcd_2_num(unsigned int bcd)
{
	// 第一步，把0x56拆分成5和6 
    
	// 第二步，把5和6组合成56
    
	return (((bcd & 0xf0)>>4)*10 + (bcd & (0x0f)));
}


void rtc_set_time(const struct rtc_time *p)
{
	// 第一步，打开RTC读写开关
    
	rRTCCON |= (1<<0);
	
	// 第二步，写RTC时间寄存器
    
	rBCDYEAR = num_2_bcd(p->year - 2000);
	rBCDMON = num_2_bcd(p->month);
	rBCDDATE = num_2_bcd(p->date);
	rBCDHOUR = num_2_bcd(p->hour);
	rBCDMIN = num_2_bcd(p->minute);
	rBCDSEC = num_2_bcd(p->second);
	rBCDDAY = num_2_bcd(p->day);
	
	// 最后一步，关上RTC的读写开关
    
	rRTCCON &= ~(1<<0);
}

void rtc_get_time(struct rtc_time *p)
{
	// 第一步，打开RTC读写开关
    
	rRTCCON |= (1<<0);
	
	// 第二步，读RTC时间寄存器
    
	p->year = bcd_2_num(rBCDYEAR) + 2000;
	p->month = bcd_2_num(rBCDMON);
	p->date = bcd_2_num(rBCDDATE);
	p->hour = bcd_2_num(rBCDHOUR);
	p->minute = bcd_2_num(rBCDMIN);
	p->second = bcd_2_num(rBCDSEC);
	p->day = bcd_2_num(rBCDDAY);
	
	// 最后一步，关上RTC的读写开关
    
	rRTCCON &= ~(1<<0);
}

void rtc_set_alarm(void)
{
	rALMSEC = num_2_bcd(23);
	rRTCALM |= 1<<0;
	rRTCALM |= 1<<6;
}

void isr_rtc_alarm(void)
{
	static int i = 0; 
	printf("rtc alarm, i = %d...", i++);
	
	rINTP |= (1<<1);
	intc_clearvectaddr();
}





```





# 2、s5pv210的SD卡

**SD卡的编程接口**

1、SD卡的物理接口

(1)SD卡由9个针脚与外界进行物理连接，这9个脚中有2个地，1个电源，6个信号线。

2、SD协议与SPI协议

(1)SD卡与SRAM/DDR/SROM之类的东西的不同：SRAM/DDR/SROM之类的存储芯片是总线式的，只要连接上初始化好之后就可以由SoC直接以地址方式来访问；但是SD卡不能直接通过接口给地址来访问，它的访问需要按照一定的接口协议（时序）来访问。

(2)SD卡虽然只有一种物理接口，但是却支持两种读写协议：SD协议和SPI协议。

3、SPI协议特点（低速、接口操作时序简单、适合单片机）

(1)SPI协议是单片机中广泛使用的一种通信协议，并不是为SD卡专门发明的。

(2)SPI协议相对SD协议来说速度比较低。

(3)SD卡支持SPI协议，就是为了单片机方便使用。



4、SD协议特点（高速、接口时序复杂，适合有SDIO接口的SoC）

(1)SD协议是专门用来和SD卡通信的。

(2)SD协议要求SoC中有SD控制器，运行在高速率下，要求SoC的主频不能太低。

5、S5PV210的SD/MMC控制器

(1)数据手册Section8.7，为SD/MMC控制器介绍。

(2)SD卡内部除了存储单元Flash外，还有SD卡管理模块，我们SoC和SD卡通信时，通过9针引脚以SD协议/SPI协议向SD卡管理模块发送命令、时钟、数据等信息，然后从SD卡返回信息给SoC来交互。工作时每一个任务（譬如初始化SD卡、譬如读一个块、譬如写、譬如擦除····）都需要一定的时序来完成（所谓时序就是先向SD卡发送xx命令，SD卡回xx消息，然后再向SD卡发送xx命令····）



SoC支持SD卡启动的秘密（iROM代码）

(1)三星系列SoC支持SD卡/NandFlash启动，主要是依靠SteppingStone技术，具体在S5PV210中支持steppingstone技术的是内部的iROM代码。

再看iROM application note：block device copy function

![](https://i.loli.net/2019/04/11/5caf585c2b51c.png)

下面说一下SD卡的分散加载启动。

启动，用的是这样的文件夹方式加载

![](https://i.loli.net/2019/04/11/5caf58c7d002a.png)

(1)总体思路：将我们的代码分为2部分：第一部分BL1小于等于16KB，第二部分为任意大小，iROM代码执行完成后从SD卡启动会自动读取BL1到SRAM中执行；BL1执行时负责初始化DDR，然后手动将BL2从SD卡copy到DDR中正确位置，然后BL1远跳转到BL2中执行BL2.

(2)细节1：程序怎么安排？程序整个分为2个文件夹BL1和BL2，各自管理各自的项目。

(3)细节2：BL1中要完成：关看门狗、设置栈、开iCache、初始化DDR、从SD卡复制BL2到DDR中特定位置，跳转执行BL2.

(4)细节3：BL1在SD卡中必须从Block1开始（Block0不能用，这个是三星官方规定的），长度为16KB内，我们就定为16KB（也就是32个block）；BL1理论上可以从33扇区开始，但是实际上为了安全都会留一些空扇区作为隔离，譬如可以从45扇区开始，长度由自己定（实际根据自己的BL2大小来分配长度，我们实验时BL2非常小，因此我们定义BL2长度为16KB，也就是32扇区）。

(5)细节4：DDR初始化好之后，整个DDR都可以使用了，这时在其中选择一段长度足够BL2的DDR空间即可。我们选0x23E00000（因为我们BL1中只初始化了DDR1，地址空间范围是0x20000000～0x2FFFFFFF）。

```c
#define SD_START_BLOCK	45
#define SD_BLOCK_CNT	32
#define DDR_START_ADDR	0x23E00000



typedef unsigned int bool;

// 通道号：0，或者2

// 开始扇区号：45

// 读取扇区个数：32

// 读取后放入内存地址：0x23E00000

// with_init：0

typedef bool(*pCopySDMMC2Mem)(int, unsigned int, unsigned short, unsigned int*, bool);

typedef void (*pBL2Type)(void);


// 从SD卡第45扇区开始，复制32个扇区内容到DDR的0x23E00000，然后跳转到23E00000去执行

void copy_bl2_2_ddr(void)
{
    
	// 第一步，读取SD卡扇区到DDR中
    
	pCopySDMMC2Mem p1 = (pCopySDMMC2Mem)(*(unsigned int *)0xD0037F98);
    
	//pCopySDMMC2Mem p1 = (pCopySDMMC2Mem)0xD0037F98);
    
	
	led2();
	delay();
	p1(2, SD_START_BLOCK, SD_BLOCK_CNT, (unsigned int *)DDR_START_ADDR, 0);		
    // 读取SD卡到DDR中
    
	led1();
	delay();
	// 第二步，跳转到DDR中的BL2去执行
    
	pBL2Type p2 = (pBL2Type)DDR_START_ADDR;
	p2();
	
	led3();
	delay();
}

```

上面是读取SD卡的函数。很重要，有必要学会，其中的函数是在IROM中实现的复制函数。

我们uboot中的方式和这里启动的方式是不一样的。这里是分散加载，并不能支持很多设备。



# 3、s5pv210的inand

inand的初始化和SD卡的初始化是一样的。

**SD卡/iNand操作**

1、硬件接口：DATA、CLK、CMD

(1)iNand的IO线有8根，支持1、4、8线并行传输模式；SD卡IO线有4根，支持1、4线并行传输模式。

(2)CMD线用来传输命令、CLK线用来传输时钟信号。

(3)接口有CLK线，工作时主机SoC通过CLK线传输时钟信号给SD卡/iNand芯片，说明：SD/iNand是同步的，SD/iNand的工作速率是由主机给它的CLK频率决定的。

2、命令响应的操作模式

(1)SD协议事先定义了很多标准命令（CMD0、CMD1·····），每个命令都有它的作用和使用条件和对应的响应。SD卡工作的时候就是一个一个的命令周期组合起来的，在一个命令周期中，主机先发送CMD给SD卡，然后SD卡解析这个命令并且执行这个命令，然后SD卡根据结果回发给主机SoC一个响应。（有些命令是不需要响应的，这时SD卡不会给主机回发响应，主机也不用等待响应）。标准的命令+响应的周期中，主机发完一个命令后应该等待SD卡的响应而不是接着发下一条命令。

3、SD/iNand的体系结构图

(1)SD卡内部有一个接口控制器，这个控制器类似于一个单片机，这个单片机的程序功能就是通过CMD线接收外部主机SoC发给SD卡的命令码，然后执行这个命令并且回发响应给主机SoC。这个单片机处理命令及回发响应遵循的就是SD协议。这个单片机同时可以控制SD卡内部的存储单元，可以读写存储单元。

4、SD/iNand的寄存器（重点是RCA寄存器）

(1)注意这里说的是SD卡内部的寄存器，而不是主机SoC的SD控制器的寄存器。（很多外置芯片内部都是有寄存器的，这些寄存器可以按照一定的规则访问，访问这些寄存器可以得知芯片的一些信息）。

(2)RCA（relative address，相对地址寄存器）。我们在访问SD卡时，实际上SD卡内部每个存储单元的地址没有绝对数字，都是使用相对地址。相对地址由SD卡自己决定的，存放在RCA寄存器中。





我不会初始化，可以在linux kernel中找到初始化的步骤，以后有机会再来学习。

